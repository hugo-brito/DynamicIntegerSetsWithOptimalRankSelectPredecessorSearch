% \part{Implementation}

% \addsec{Unnumbered level}

% \section{First level}
% \subsection{Second level}
% \subsubsection{Third level}
% \paragraph{Forth level}
% \subparagraph{Fifth level}

% \subsection{Dummy subsection}

% This is some text to showcase the features of this thesis template. For example, it is possible to add a side note with\myMarginnote{I am a side note!}.

% In this paragraph, I will add an image as a template:
% \begin{figure}[H]
% \centering
% 	\includegraphics[width=0.9\textwidth]%
% 	{03_GraphicFiles/CowLickingNose.jpg}%
% \caption[A cow]{A cow licking its nose. Usage with permission of the photographer \textsc{Nicole Barth}, taken from \url{www.flickr.com/photos/46311827@N07/14885545396}.}
% \label{fig:CowLickingNose}
% \end{figure}

% In \figurename~\ref{fig:CowLickingNose}\myMarginnote{Reference to a figure} you see a cow that is licking its nose. The picture was taken by Nicole Barth on 11.08.2014 using a Canon EOS 500D. The original file has a resolution of $4247 \times 2831$ pixels.
% Note that the image is also referenced.

\chapter{Background}

The \cite{patrascu2014dynamic} paper presents a dynamic data structure for storing integers and claims that its running times are optimal.
In this chapter, a series of data structures, techniques and other relevant aspects will be presented, laying the foundation for the implementation of the data structure presented by Pătrașcu and Thorup.

\section{Basic Concepts}

\subsection{Word}
A word consists of a $w$-bit integer. This means that we are bound to an universe $\mathcal U = \{0, 1, ..., 2^{w}-1\}$. The bits which a word is comprised of are indexed from the least (left) to the most (right) significant bit, having the least significant bit index $0$, whereas the most significant has index $w-1$.

\subsection{Universe}
The universe of all possible keys, denoted by $\mathcal U$, has size $u = 2^{w}$, e.g., all combinations of $w$-bit words.

\subsection{The Predecessor Problem}\label{sec:predecessorProblem}
Data structures that maintain a set, $S$ of (integer) keys and enable the following operations are said to solve the static predecessor problem \cite{beame1999optimal}:
\begin{itemize}
    \item
    $member(x)$ returns $[x \in S]$.
    \item
    $predecessor(x)$ returns $max\{y\in S\ |\ y < x\}$.
    \item
    $successor(x)$ returns $min\{y\in S\ |\ y \geq x\}$.
\end{itemize}

The predecessor problem can also be dynamic \cite{beame1999optimal} if the said data structure also allows:
\begin{itemize}
    \item
    $insert(x)$ sets $S=S \cup \{x\}$.
    \item
    $delete(x)$ sets $S=S \setminus \{x\}$.
\end{itemize}

In this context, the following operations might also be relevant:
\begin{itemize}
    \item
    $rank(x)$ returns $\#\{ y \in S\ |\ y < x\}$.
    \item
    $select(i)$ returns $y \in S$ with $rank(y) = i$, if any.
\end{itemize}

In particular, the data structure presented in \cite{patrascu2014dynamic} not only implements all of the above, but it also establishes that by having the operations defined in this manner \cite{patrascu2014dynamic}:
\begin{itemize}
    \item
    $predecessor(x) = select(rank(x - 1))$
    \item
    $successor(x) = select(rank(x))$
\end{itemize}

Given this set of standard operations, this data structure solves the dynamic predecessor problem.

\subsection{Models of Computation}\label{sec:modelsofcomputation}

In order to analyze and describe running times, authors resort to models of computation. Each model states which operations have an associated cost, and which ones do not.
These models provide no unit of cost, and the given operations either have one unit of cost or none.

Despite their theoretical relevance, when having a data structure and its operations measured against wall clock, one might be surprised with the results.
This is because theoretical bounds have the potential to hide big constants, which are brought to light when wall clock measurements are performed.
Nevertheless, we will enumerate some models of computation, as many of the data structures here presented have their running times described in terms of a given model, and therefore, it is of interest to provide this context.

The models are presented in descending order from strongest to the least strong. This means that a less restrictive model, such as the cell-probe model, is more suited to describe the theoretical \emph{lower} bounds of a data structure than the least stronger ones \cite{erikdemainelec11}.

\subsubsection{The Cell-Probe Model}
In the cell-probe model, memory is divided into cells of size $w$, a parameter of the model. Every computation is free.
The only operations that come with an associated cost are reading or writing to memory, which are basically the memory accesses.
Due to its simplicity, as stated in \ref{sec:modelsofcomputation}, it is widely used to prove lower bounds \cite{erikdemainelec11}.

\subsubsection{Trans-dichotomous RAM}
In the trans-dichotomous RAM model, memory consists of an array of size $S$ of $w$-bit words.
Reading or writing to one of the memory cells costs $O(1)$.
Additionally, memory cells can be used as pointers to other cells, e.g., a single $w$-bit word can be used to access another cell.
This implies that the word length $w$ has to be large enough to be able to index all to access all cells in the memory.
Let the problem size be $n$:
\begin{equation}\label{eq:problemSize}
    w \ge \log_2(S) \implies w \ge \log_2(n)
\end{equation}
The name is due to expression~\ref{eq:problemSize}, which relates two dichotomies: problem size $n$; and the model of computation with words of size $w$ \cite{erikdemainelec11}. 

\subsubsection{Word RAM}
Like the trans-dichotomous RAM model, the word RAM also operates with fixed size $w$-bit words. Additionally, the following operations have an associated cost \cite{nelsonjelanilec1}:
\begin{itemize}
    \item Integer arithmetic (addition $+$, subtraction $-$, multiplication $\times$, division $\div$ and remainder of division (modulo) $\bmod$);
    \item Bit-wise operations (negation $\neg$, and $\wedge$, or $\vee$, exclusive or $\oplus$);
    \item Bit-wise shifting operations (right bit-shift $\gg$, left bit-shift $\ll$).
\end{itemize}

\section{Integer Sets}

Table~\ref{tab:dataStructComparison} is a summary of relevant data structures that incrementally lead to the data structure presented in this project.

\begin{table}[H]
\centering
\input{src/tex/04_Tables/001_DataStructuresComparison.tex}
\caption[Data structure comparison]{Data structures used to solve the predecessor problem and their respective theoretical running times.}
\label{tab:dataStructComparison}
\end{table}

\subsection{Binary Search Tries}

\subsection{Patricia Tries}

\subsection{Fusion Trees}

\section{Summary of techniques used in the present implementation}

All of the algorithms presented in this section have been implemented as static functions in the {\ttfamily Util} class.

\subsection{Bit operations} \label{sec:bit}

Let $A$ be a $w$-bit length word. This section features a set of functions that operate on $A$'s bits. Since these operations only use bit-wise shifting and masking, all the algorithms presented in this section take $O(1)$ time.

\subsubsection{Is the bit set}

This operation aims at extracting the bit at position $d$ in $A$ or, in other words, getting the value of the bit at position $d$. Let us denote such operation by bit$(d, A)$, then:
\begin{align*}
    \text{bit}(d, A) = (A \gg d) \wedge 1
\end{align*}

Example:
\begin{align*}
    w = 16\\
    d = 8\\
    A = 0101\ 110\underline{1}\ 1100\ 0111_2& \\
    \text{bit}(8,A) = (0101\ 110\underline{1}\ 1100\ 0111_2& \gg 8) \wedge 1 \\
    \cline{1-2}
    \text{bit}(8,A) = 0000\ 0000\ 0101\ 110\underline{1}_2& \\
    \wedge\ 0000\ 0000\ 0000\ 000\underline{1}_2 \\
    \cline{1-2}
    \text{bit}(8,A) = 1 &
\end{align*}

\subsubsection{Set bit}
This operation sets the bit at position $d$ in $A$ to one. Let us denote such operation by setBit$(d, A)$, then:
\begin{align*}
    \text{setBit}(d, A) = A \vee (1 \ll d)
\end{align*}

Example:
\begin{align*}
    w = 16\\
    d = 4\\
    A = 0101\ 1101\ 110\underline{0}\ 0111_2& \\
    \text{setBit}(4,A) = 0101\ 1101\ 110\underline{0}\ 0111_2& \vee (1 \ll 4) \\
    \cline{1-2}
    \text{setBit}(4,A) = 0101\ 1101\ 110\underline{0}\ 0111_2& \\
    \vee\  0000\ 0000\ 000\underline{1}\ 0000_2& \\
    \cline{1-2}
    \text{setBit}(4,A) = 0101\ 1101\ 110\underline{1}\ 0111_2&
\end{align*}

\subsubsection{Delete bit}
This operation sets the bit at position $d$ in $A$ to zero. Let us denote such operation by deleteBit$(d, A)$, then:
\begin{align*}
    \text{deleteBit}(d, A) = A \wedge \neg(1 \ll d)
\end{align*}

Example:
\begin{align*}
    w = 16\\
    d = 6\\
    A = 0101\ 1101\ 1\underline{1}00\ 0111_2& \\
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{1}00\ 0111_2& \wedge \neg(1 \ll 6) \\
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{1}00\ 0111_2&\\
    \wedge\ \neg(0000\ 0000\ 0\underline{1}00\ 0000_2&) \\
    \cline{1-2}
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{1}00\ 0111_2& \\
    \wedge\ 1111\ 1111\ 1\underline{0}11\ 1111_2 \\
    \cline{1-2}
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{0}00\ 0111_2&
\end{align*}

\subsection{Masks} \label{sec:masks}

Pătrașcu and Thorup refer to some useful constants that we will denote by masks, which are useful for bit-wise operations. In this section, we will see how we can compute them.

\begin{itemize}
    \item
    The mask $0^{w-j} 1^j_2$ consists of a word with $w-j$ significant bits set to zero, and the least $j$ significant bits set to one. It is useful for instance, to mask the first $j$ least significant bits of a word and it is computed with the expression:
    \begin{align*}
        0^{w-j} 1^j_2 = (1 \ll j) - 1
    \end{align*}
    Example:
    \begin{align*}
        w &= 16\\
        j &= 4\\
        \cline{1-2}
        0^{16-4} 1^4_2 &= (1 \ll 4) - 1\\
        &= (0000\ 0000\ 0000\ 0001_2 \ll 4) - 1\\
        &= 0000\ 0000\ 0001\ 0000_2 - 1\\
        &= \underbrace{0000\ 0000\ 0000}_{w-j}\ \underbrace{1111}_{j}{}_2
    \end{align*}
    
    \item
    The mask $1^{w-j} 0^j_2$ consists of a word with $w-j$ significant bits set to one, and the least $j$ significant bits set to zero. For instance, it is useful to mask the first $w - j$ most significant bits of a word. It is easily computed by negating the result from the previous expression:
    \begin{align*}
        1^{w-j} 0^j_2= \neg((1 \ll j) - 1)
    \end{align*}
    Example:
    \begin{align*}
        w &= 16\\
        j &= 4\\
        \cline{1-2}
        1^{16-4} 0^4_2 &= \neg((1 \ll 4) - 1)\\
        &= \neg((0000\ 0000\ 0000\ 0001_2 \ll 4) - 1)\\
        &= \neg(0000\ 0000\ 0001\ 0000_2 - 1)\\
        &= \neg0000\ 0000\ 0000\ 1111_2\\
        &= \underbrace{1111\ 1111\ 1111}_{w-j}\ \underbrace{0000}_{j}{}_2
    \end{align*}
\end{itemize}

\subsection{Fields of words} \label{sec:fieldsOfWords}

We follow the definitions from \cite{patrascu2014dynamic} in regards to viewing words as sets of fields of some length $f \leq w$. Let $A$ be a $w$-bit length word, then if $A$ is comprised of fields, analogously to bit indexing of a word, its least significant field is the rightmost one, denoted $A\langle0\rangle_f$; its most significant field is the leftmost one, denoted $A\langle f-1\rangle_f$, and so on.
Note that the functions presented in this section consist of simple bit-wise shifting and masking with the expressions defined in \ref{sec:masks}. Regarding running times, all these algorithms take $O(1)$ time.

\subsubsection{Field retrieval} \label{sec:fieldRetrieval}

This operation consists of retrieving field $A\langle i\rangle_f$ and it is denoted by getField$(i, f, A)$. It is defined by:
\begin{align*}
    \text{getField}(i, f, A) = (A \gg (i \times f)) \wedge ((1 \ll f) - 1)
\end{align*}

Example:
\begin{align*}
    i = 1\\
    f = 4\\
    A = 0101\ 1101\ \underline{1100}\ 0111_2& \\
    \text{getField}(1, 4, A) = (0101\ 1101\ \underline{1100}\ 0111_2& \gg (\underbrace{1 \times 4}_{4})) \wedge (\underbrace{(1 \ll 4) - 1}_{1111_2})\\
    \cline{1-2}
    \text{getField}(1, 4, A) = 0000\ 0101\ 1101\ \underline{1100}_2& \\
    \wedge\ 0000\ 0000\ 0000\ 1111_2& \\
    \cline{1-2}
    \text{getField}(1, 4, A) = 0000\ 0000\ 0000\ \underline{1100}_2&
\end{align*}

A range of fields can be retrieved in a single operation. We denote by getFields$(i, j, f, A)$ the operation consisting of retrieving the fields $\{A\langle i\rangle_f,\dots , A\langle j-1\rangle_f\}$, which is defined by:
\begin{align*}
    \text{getFields}(i, j, f, A) = (A \gg (i \times f)) \wedge ((1 \ll ((j - i) \times f)) - 1)
\end{align*}

Example:
\begin{align*}
    i = 1\\
    j = 3\\
    f = 4\\
    A = 0101\ \underline{1101}\ \underline{1100}\ 0111_2& \\
    \text{getFields}(1, 2, 4, A) = (0101\ \underline{1101}\ \underline{1100}\ 0111_2& \gg (\underbrace{1 \times 4}_{4})) \wedge (\underbrace{(1 \ll ((3 - 1) \times 4)) - 1}_{1111\ 1111_2})\\
    \cline{1-2}
    \text{getFields}(1, 2, 4, A) = 0000\ 0101\ \underline{1101}\ \underline{1100}_2&\\
    \wedge\ 0000\ 0000\ 1111\ 1111_2 \\
    \cline{1-2}
    \text{getFields}(1, 2, 4, A) = 0000\ 0000\ \underline{1101}\ \underline{1100}_2&
\end{align*}

We can also specify a lower field and retrieve all the fields from that position up to the end of the word. This is denoted by getFields$(i, f, A)$ and it is defined by:
\begin{align*}
    \text{getFields}(i, f, A) = A \gg (i \times f)
\end{align*}

Example:
\begin{align*}
    i = 2\\
    f = 4\\
    A = \underline{0101}\ \underline{1101}\ 1100\ 0111_2& \\
    \text{getFields}(2, 4, A) = \underline{0101}\ \underline{1101}\ 1100\ 0111_2& \gg (\underbrace{2 \times 4}_{8})\\
    \cline{1-2}
    \text{getFields}(1, 2, 4, A) = 0000\ 0000\ \underline{0101}\ \underline{1101}_2&
\end{align*}

\subsubsection{Field assignment}

Conversely, it is also possible to assign a value to a particular field. To do so, a mask $m$ is required, and it is computed as a function of $i$ (the position of the field to be set) and $f$ (the length of the fields in $A$). Thus we have:
\begin{align*}
    m = ((1 \ll f) - 1) \ll (i \times f)
\end{align*}
 Setting field $y$ in $A$, denoted by setField$(i, y, f, A)$ is defined by:
\begin{equation*}
    \text{setField}(i, y, f, A) = \underbrace{(A \wedge \neg m)}_{\text{(a) Reset field}} \vee \ \underbrace{(y \ll (i \times f) \wedge m)}_{\text{(b) Set field}}
\end{equation*}
Example:
\begin{align*}
    i = 1\\
    y = 1001_2\\
    f = 4\\
    m = (\underbrace{(1 \ll 4)  - 1} _{1111_2}) \ll (\underbrace{1 \times 4}_{4}) = 0000\ 0000\ 1111\ 0000_2\\
    A = 0101\ 1101\ \underline{1100}\ 0111_2& \\
    \cline{1-2}
    \text{(a)}\quad A \wedge \neg m = 0101\ 1101\ \underline{1100}\ 0111_2 \\
    \wedge\ 1111\ 1111\ 0000\ 1111_2\\
    \text{(a)}\quad = 0101\ 1101\ 0000\ 0111_2\\
    \cline{1-2}
    y \ll (1 \times 4) = 0000\ 0000\ 0000\ \underline{1001}_2& \ll 4\\
    = 0000\ 0000\ \underline{1001}\ 0000_2\\
    \text{(b)}\quad (y \ll 4) \wedge m = 0000\ 0000\ \underline{1001}\ 0000_2\\ 
    \wedge\ 0000\ 0000\ 1111\ 0000_2\\
    \text{(b)}\quad = 0000\ 0000\ \underline{1001}\ 0000_2\\
    \cline{1-2}
    \text{setField}(1, y, 4, A) = \text{(a)} \vee \text{(b)} = 0101\ 1101\ \underline{0000}\ 0111_2\\
    \vee\ 0000\ 0000\ \underline{1001}\ 0000_2 \\
    \cline{1-2}
    \text{setField}(1, y, 4, A) = 0101\ 1101\ \underline{1001}\ 0111_2&
\end{align*}

\subsection{Most significant set bit} \label{sec:msbAlgorithm}

Learning about the most significant set bit of a word will be an important operation in the implementation. For this reason, we will look at different ways to achieve this result. Since it is to be used as a subroutine in certain operations, it has the potential to become a bottleneck if not implemented carefully. We denote the most significant set bit of $x$ by msb$(x)$.

\subsubsection{Naive}

The simplest way to achieve the intended outcome is to loop through the word until the first non-zero bit is found, returning the number of iterations that it took to find that bit.

This approach takes $O(w)$ time.

\subsubsection{Lookup}

In this approach, a lookup table containing the most significant bits answers for all combinations of 8 bits is pre-computed.

When a query comes, it is iterated in fields of 8 bits, starting from the most significant field. If that field is not zero, then the most significant bit of the queried word lies in that block. In such a case, the answer will be the most significant set bit of that field plus all the bits in the non-iterated fields. Since the answer to any combination of 8 bits is pre-computed, we know the answer in constant time.

Otherwise, if the first field zero, the algorithm looks at the second most significant field and does the same operation as described in the previous paragraph.

This approach takes $O(1)$ time after the lookup table has been computed but, not only the lookup table takes time to compute, it also uses some space.

\subsubsection{Constant time with parallel comparison} \label{sec:msbO1}

This operation consists of 4 steps. Let $x$ be the query for the most significant set bit:
\begin{enumerate}
    \item
    We divide $x$ in $\sqrt{w}$ fields of $\sqrt{w}$ bits. The goal is to summarize the fields in $x$ such that if a field is not empty, then its summary is $1$ and $0$ (zero) otherwise.
    \item
    We compress the summary such that it fits in a single $\sqrt{w}$-bits field. The resulting field will have all the leading bits of the summary word consecutive.
    \item
    Then we do parallel comparison of the summary word to find the first non-empty field of $x$ because it will be on that field that the answer will lie.
    \item
    We use the same technique as in the previous bullet point, but now on the first non-empty field of $x$. We end with simple arithmetic to return the most significant set bit. 
\end{enumerate}

We will run a small example where every step will be illustrated. For simplicity, let $w=16$. This implies that we will have $\sqrt{16} = 4$ fields of $4$ bits in size each. Let us also assume that our query $x = 0101\ 0000\ 1000\ 1101_2$.

This approach takes $O(1)$ time and requires a small lookup table of $\sqrt{w}/2$ size, which can easily be explicitly stored together with the algorithm.

\paragraph{Step 1 --- Summarize the query fields} \label{sec:summaryfields}

The goal of this step is to compute a summary word whose leading bit of each of its fields is a summary of each field of the query word $x$. If in a given field $f_i$, the leading bit in the summary word is $1$, then $f_i$ in $x$ was not empty (one or more bits were set), and vice-versa.

\begin{enumerate}
    \item \label{blt:msb1}
    We start by finding $F$. $F$ is a $w$-bit word where the most significant position of every field is set to $1$ and every other position is set to $0$. In this particular example $F = 1000\ 1000\ 1000\ 1000_2$
    
    \item \label{blt:msb2}
    In a local variable $t_1$, we store information about the leading bits of each field of $x$. This is done with $x \wedge F$.
    \begin{align*}
                       x &= \underline{0}101\ \underline{0}000\ \underline{1}000\ \underline{1}101_2 \\
                       F &= 1000\ 1000\ 1000\ 1000_2 \\ \cline{1-2} 
        t_1 = x \wedge F &= \underline{0}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2
    \end{align*}
    
    \item \label{blt:msb3}
    In another local variable $t_2$, we store $x$ after setting the leading bits of each field to zero. This is done with $x \oplus t_1$.
    \begin{align*}
                         x &= 0\underline{101}\ 0\underline{000}\ 1\underline{000}\ 1\underline{101}_2 \\
                       t_1 &= 0000\ 0000\ 1000\ 1000_2 \\ \cline{1-2}
        t_2 = x \oplus t_1 &= 0\underline{101}\ 0\underline{000}\ 0\underline{000}\ 0\underline{101}_2
    \end{align*}
    
    \item \label{blt:msb4}
    We subtract $t_2$ from $F$ and save it to a local variable $t_3$. Since the leading bit of every field of $F$ is one, after subtracting $t_2$ to $F$, what remains is the information about if that field was empty (all zeros) or not. This information is given by the bit that remains at the most significant position of each resulting field. In other words, if in any given field of the resulting word, the most significant bit is one, then the corresponding field in $x$ was empty; otherwise, it was not empty.
    
    Since we only care about what remains of the most significant position of each field, in the example below, the remaining noise has been replaced with $?$.
    \begin{align*}
                    F &= 1000\ 1000\ 1000\ 1000_2 \\
                  t_2 &= 0\underline{101}\ 0\underline{000}\ 0\underline{000}\ 0\underline{101}_2 \\ \cline{1-2} 
        t_3 = F - t_2 &= \underline{0}???\ \underline{1}000\ \underline{1}000\ \underline{0}???_2
    \end{align*}
    
    \item \label{blt:msb5}
    This step consists of clearing the noise from $t_3$ since we care only about knowing which fields in $x$ were empty or not. To do so, $(\neg t_3) \wedge F$.
    \begin{align*}
                       t_3 &= \underline{0}???\ \underline{1}000\ \underline{1}000\ \underline{0}???_2 \\ \cline{1-2} 
            t_4 = \neg t_3 &= \underline{1}???\ \underline{0}111\ \underline{0}111\ \underline{1}???_2 \\
                         F &= 1000\ 1000\ 1000\ 1000_2 \\ \cline{1-2} 
        t_5 = t_4 \wedge F &= \underline{1}000\ \underline{0}000\ \underline{0}000\ \underline{1}000_2
    \end{align*}
    
    \item \label{blt:msb6}
    The value calculated in \ref{blt:msb2} for $t_1$ holds information about the leading bits of each field, whereas $t_5$ from \ref{blt:msb5} contains the information about the non-leading bits. By merging both words, the resulting word will hold information about the whole word $x$. We achieve this with $t_1 \vee t_5$.
    \begin{align*}
                       t_1 &= \underline{0}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2 \\
                       t_5 &= \underline{1}000\ \underline{0}000\ \underline{0}000\ \underline{1}000_2 \\ \cline{1-2} 
        t_6 = t_1 \vee t_5 &= \underline{1}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2
    \end{align*}
\end{enumerate}

In fact, once $F$ is known, steps \ref{blt:msb2} to \ref{blt:msb5} can be computed all at once with the expression:
\begin{equation}
    t_6 = (x \wedge F) \vee ((\neg(F - (x \oplus(x \wedge F)))) \wedge F)
\end{equation}

\paragraph{Step 2 --- Summary compression} \label{sec:summaryCompression}
% minuto 1.12: https://www.youtube.com/watch?v=xSGorVW8j6Q&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=12

The goal of this step is to compress the summary word down to a single field.

\begin{enumerate}
    \item \label{blt:summCompression1}
    The first step consists of shifting the leading bits of each field to the least significant position of each field. This is done with $t_6 \gg (\sqrt{w} - 1)$. 
    \begin{align*}
                    t_6 &= \underline{1}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2 \\ \cline{1-2} 
        t_7 = t_6 \gg 3 &= 000\underline{1}\ 000\underline{0}\ 000\underline{1}\ 000\underline{1}_2
    \end{align*}
    
    \item \label{blt:summCompression2}
    We wish now to copy the least significant bit of each field to a single field, keeping their relative order.
    Similarly to \ref{sec:summaryfields}.\ref{blt:msb1}, we need to find a word $C$ which, when multiplied by $t_6$, will produce the result we are looking for.
    Let $C$ be also partitioned in fields indexed $\{f_0, ..., f_{\sqrt{w} - 1}\}$ where $f_{\sqrt{w} - 1}$ is the most significant field. At every field $f_i$, the only set bit is $b_{\sqrt{w} - 1 - i}$).
    In our example $C = 0001\ 0010\ 0100\ 1000_2$.
    
    \item \label{blt:summCompression3}
    Multiplying $C$ with $t_7$ produces a result $t_8$ with all the important bits in their relative order in the most significant field. There will be some additional noise in the least significant fields, which we can easily clear by $t_8 \gg ((\sqrt{w})\cdot(\sqrt{w} - 1))$.
        \begin{align*}
                         t_7 &= 000\underline{1}\ 000\underline{0}\ 000\underline{1}\ 000\underline{1}_2 \\
                           C &= 0001\ 0010\ 0100\ 1000_2 \\ \cline{1-2} 
          t_8 = t_7 \times C &= \underline{1011}\ ????\ ????\ ????_2\\ \cline{1-2}
        x_s = t_8 \gg (16-4) &= 0000\ 0000\ 0000\ \underline{1011}_2
    \end{align*}
\end{enumerate}

\paragraph{Step 3 --- First non-empty field with parallel comparison} \label{sec:parallel}
At this stage, the goal is to compute the first non-empty field of $x$. To do so, we need to do a parallel comparison between $x_s$ (the summary of $x$'s fields) and all the $\sqrt{w}$ powers of two.

The parallel comparison consists of:
\begin{enumerate}
    \item
    Taking a query $x$ of length $l < w$, making as many copies of it as there are other vectors we wish to compare it with while padding these copies with zero. The resulting vector is stored in a word.
    
    \item
    The vectors we wish to compare $x$ with are stored in word $A$ with each of their leading bits padded with one.
    
    \item
    We take the difference between $A$ and the copies of $x$, checking how many of the padding bits remain one in $A$ after this operation. The result stands for the number of vectors in $A$ that were strictly smaller than $x$.
\end{enumerate}

Since the vector we want to compare $x_s$ with consists of $\sqrt{w}$ powers of two, then we know that we will need $\sqrt{w}\cdot(\sqrt{w} + 1)$ bits to store all such vectors. This extra bit per vector is due to the padding bit mentioned earlier. Since $\sqrt{w}\cdot(\sqrt{w} + 1) > w$, we know also that it might be necessary to do this operation in two iterations. Since a word does not hold enough bits to perform the comparison with a single word, we will split the vectors in two words: one representing the higher $\sqrt{w}/2$ powers of two, and another for the lower ones.

If the power of two vectors are sorted, this parallel comparison will be a monotone function, meaning that once the transition on the leading bit is found, the result is found. This also implies that if the result is found in the higher powers of two, then it is unnecessary to look for it in the lower end.

\begin{enumerate}
    \item \label{blt:parallel1}
    We define two bit vectors, $hi$ and $lo$, with $hi > lo$. These vectors are comprised of the concatenation of the $\sqrt{w}$ powers of two in sorted in descending order and padded with $1$. To each power of two, we have to subtract $1$ for this operation to work, because if we do not and the query is an exact power of two, the corresponding padding $1$ will not be borrowed. In our example:
    \begin{align*}
        hi &= 1\ \underbrace{0111}_{2^3-1=7}\ 1\ \underbrace{0011}_{2^2-1=3}{}_2\\
        lo &= 1\ \underbrace{0001}_{2^1-1=1}\ 1\ \underbrace{0000}_{2^0-1=0}{}_2
    \end{align*}
    
    \item \label{blt:parallel2}
    We define another vector $t_9$ consisting of $\sqrt{w}/2$ concatenated copies of $x_s$ where each of the copies is prefixed by zero. This vector is achieved by multiplying $x_s$ with a word $M$ consisting of $\sqrt{w}/2$ fields of size $\sqrt{w} + 1$ where the least significant bit of each field is set to $1$. Note that, because we have set the size of each field of $M$ to have an additional bit, this corresponds to prefix a zero to each $\sqrt{w}$ field:
    \begin{align*}
        x_s = 0000\ 0000\ 0000\ &\underline{1011}_2\\ 
        M = 0\ 0001\ 0\ &0001_2\\ \cline{1-2}
        t_9 = x_s \times M = 0\ \underline{1011}\ 0\ &\underline{1011}_2
    \end{align*}
    
    \item \label{blt:parallel3}
    To find the first non-empty field of $x$, we take the differences between $t_9$ and $hi$ and $lo$ respectively. The answer will lie one the first field which leading bit resulted in a zero after the operation.
    \begin{align*}
                          hi &= \underline{1}\ \underline{1}000\ \underline{1}\ \underline{01}00_2\\
                          lo &= \underline{1}\ \underline{001}0\ \underline{1}\ \underline{0001}_2 \\
                      t_9 &= 0\ 1011\ 0\ 1011_2\\ \cline{1-2}
        t_{10} = hi - t_9 &= \underline{0}\ ????\ \underline{0}\ ????_2 \\
        t_{11} = lo - t_9 &= \underline{0}\ ????\ \underline{0}\ ????_2
    \end{align*}
    
    \item \label{blt:parallel4}
    Looking at $t_{10}$, we note that the first non-empty field of $x$ is the most significant one because the leading bit of first field resulting from the difference between $hi$ and $t_9$ is now zero. Nevertheless, we will do the same operations on both $t_{10}$ and $t_{11}$ and concatenate the results, so we end up with a single result for the whole query. Note that in the previous step, the actual values within each field besides the leading bit are irrelevant, so we do some masking and shifting, similar to what was done in \ref{sec:summaryfields} and \ref{sec:summaryCompression}.
    \begin{enumerate}
        \item
        The first step is to clear all the irrelevant bits in the fields and turn the leading bits from zero to one. We choose a mask for this specific purpose.
        \begin{align*}
            t_{10} = \underline{0}\ ????\ \underline{0}\ ????_2&\\
            t_{11} = \underline{0}\ ????\ \underline{0}\ ????_2&\\
            Mask_1 = 1\ 0000\ 1\ 0000_2&\\ \cline{1-2}
            t_{12} = (t_{10} \wedge Mask_1) \oplus Mask_1 = \underline{1}\ 0000\ \underline{1}\ 0000_2&\\
            t_{13} = (t_{11} \wedge Mask_1) \oplus Mask_1 = \underline{1}\ 0000\ \underline{1}\ 0000_2&
        \end{align*}
        \item
        Secondly, we wish to summarize the results in a single field. To achieve so, we first multiply the vectors by an integer $V$, which construction follows what we have done for \ref{sec:summaryCompression}.\ref{blt:summCompression2}, and that result will put all the important bits consecutive in the most significant field.
        
        \begin{align*}
            t_{14} = t_{12} \gg \sqrt{w} = 0\ 000\underline{1}\ 0\ 000\underline{1}_2& \\
            t_{15} = t_{13} \gg \sqrt{w} = 0\ 000\underline{1}\ 0\ 000\underline{1}_2& \\
            \cline{1-2}
            V =\ 01000\ 10000_2 & \\
            t_{16} = t_{14} \times V =\ ???????\ \underline{11}00?\ ?????_2& \\
            t_{17} = t_{15} \times V =\ ???????\ \underline{11}00?\ ?????_2& \\
        \end{align*}
        \item
        After the multiplication, we have to remove the noise and move the result to the least significant field. We achieve this by defining another mask for this purpose, followed by the necessary bit shifts. The final step will be to merge the results of the higher and the lower powers of two: $t_{hi} \vee t_{lo}$.
        
        \begin{align*}
            Mask_2 = (1 \ll (\sqrt{w}/2)) - 1 = 11_2&\\
            t_{18} = t_{16} \wedge (Mask_2 \ll 2\cdot \sqrt{w}) =\ \underline{11}\ 0000\ 0000_2& \\
            t_{19} = t_{17} \wedge (Mask_2 \ll 2\cdot \sqrt{w}) =\ \underline{11}\ 0000\ 0000_2& \\
            \cline{1-2}
            t_{hi} = t_{18} \gg (\sqrt{w} + \sqrt{w}/2) = 00\ 0000\ \underline{11}00_2 &\\
            t_{lo} = t_{19} \gg (\sqrt{w} \cdot \sqrt{w} / 2) = 00\ 0000\ 00 \underline{11}_2 &\\
            \cline{1-2}
            t_{q} = t_{hi} \vee t_{lo} = \underline{1111}_2 &\\
        \end{align*}
    \end{enumerate}
    \item
    Note that $t_q$ can only be one of $\sqrt{w}$ possibilities: $0001_2$, $0011_2$, $0111_2$, or $1111_2$. For this reason, we implement a lookup table of size $\sqrt{w}$ for these values, which we return at the end of the method. We can even halve the size of the lookup table by applying the following trick: instead of merging $t_{hi}$ and $t_{lo}$ into a single field, shift $t_{hi}$ all the way to the right. In this scenario, $t_{hi}$ can either be $11_2$, $01_2$ or $0$. The values of the lookup table, in this case, will be only $11_2$ and $01_2$, so if $t_{hi}$ takes one of those values, we return the value in the lookup table plus a constant corresponding to the least significant positions ($\sqrt{w}/2$). Should it be $0$, then we do the lookup for $t_{lo}$ and return the corresponding value in the lookup table.
    
    In our example, since $t_{q} = 1111_2$ the result of this parallel comparison would be $3$ (three), meaning, the method should now look at $x\langle 3\rangle_4$ (the most significant field).
\end{enumerate}

\paragraph{Step 4 --- Final result}
After learning in which field lies the most significant bit, we now run the same method as in \ref{sec:parallel} but now with the actual field.

\begin{enumerate}
    \item
    We start by extracting the field from our query $x$. Let $i$ be the result returned from \ref{sec:parallel}, e.g. the index of the field. We extract $f_i$ by shifting $(\sqrt{w} - 1 - i)$ fields in $x$ to the right and ANDing the result with a mask for this purpose.
    \begin{align*}
        x = \underline{0101}\ 0000\ 1000\ 1101_2 &\\
        Mask_3 = (1 \ll \sqrt{w}) - 1 = 0000\ 0000\ 0000\ 1111_2 &\\
        \cline{1-2}
        t_{20} = (x \gg \underbrace{(\sqrt{w} \cdot (\sqrt{w} - 1 - i))}_{4\times(4-1-0)}\ \wedge\ Mask_3 = 0000\ 0000\ 0000\ \underline{0101}_2 &
    \end{align*}
    \item
    We run another parallel comparison with $0101_2$. Let $d$ be the result of computing the parallel comparison of the first non-empty field of $x$, then in our example $d = 2$.
    \item
    We can now compute the overall most significant bit of $x$. The final result is given the expression:
    \begin{equation*}
        \text{msb}(x) = d + i\cdot\sqrt{w}
    \end{equation*}
    In our example, this will evaluate to:
    \begin{equation*}
        \text{msb}(0101\ 0000\ 1000\ 1101_2) = 2 + 3\cdot\sqrt{16} = 2 + 3 \times 4 = 14
    \end{equation*}
\end{enumerate}

\subsection{Least significant set bit} \label{sec:lsbAlgorithm}

Let lsb$(x)$ denote the least significant set bit of $x$. Citing Pătrașcu and Thorup, after computing the msb$(x)$ we can in $O(1)$ time compute lsb$(x)$ with the expression:
\begin{equation*}
    \text{lsb}(x) = \text{msb}((x - 1) \oplus x)
\end{equation*}

Example:
\begin{align*}
    x = 0101\ 1101\ 1100\ 0\underline{1}00_2& \\
    x - 1 = 0101\ 1101\ 1100\ 0\underline{0}11_2& \\
    (x - 1) \oplus x = 0000\ 0000\ 0000\ 0\underline{1}00_2& \\
    \cline{1-2}
    \text{lsb}(x) = \text{msb}((x - 1) \oplus x) = \text{msb}(0000\ 0000\ 0000\ 0\underline{1}00_2&) = 2
\end{align*}

\subsection{Rank Lemma 1} \label{sec:rankLemma1}

Another important operation in the context of the implementation of the data structure presented in \cite{patrascu2014dynamic} is to compute the rank of a word. For this purpose, some subroutines are required, and the algorithm described in this section is one of them. This algorithm consists of the implementation of Lemma~\ref{lemma1} by Fredman and Willard, cited by Pătrașcu and Thorup. It reads:
\begin{lemma} \label{lemma1}
Let $m \cdot b \leq w$. If we are given a b-bit number x and a word A with m b-bit numbers stored in sorted order, that is, $A\langle 0 \rangle_b < A\langle 1 \rangle_b < \dots < A\langle m - 1 \rangle_b$, then in constant time, we can find the rank of x in A, denoted rank(x,A).
\end{lemma}
An algorithm that implements rank$(x,A)$ works as the following:
\begin{enumerate}
    \item
    Computing how many fields in $A$ have zero as their leading bit.
    
    \item
    Computing the leading bit of $x$.
    
    \item
    If the leading bit of $x$ is zero, then:
    \begin{enumerate}
        \item
        We bit-shift and mask $A$ as needed, such that the fields whose leading bit is one are no longer present in $A$.
        
        \item
        We compute a word consisting of as many concatenated copies of $x$ as there are fields left in $A$.
        
        \item
        We do parallel comparison\footnote{See Section~\ref{sec:parallel} to learn more about parallel comparison.} between (the shifted/masked) $A$ and (copies of) $x$ by setting the leading bit of each of the remaining fields of $A$ to one and computing the difference between those words.
        
        \item
        The result of rank$(x,A)$ is given by the number of fields whose leading bit is now zero because if the leading bit (that has been set to one in the previous step) is borrowed in the subtraction, then $x$ is larger than the key stored at that field.
    \end{enumerate}
    
    Otherwise, if the leading bit of $x$ is one, then:
    \begin{enumerate}
        \item
        We bit-shift and/or mask $A$ such that the fields whose leading bit is zero are no longer present in $A$, storing the number of fields removed from $A$ on a local variable.
        
        \item
		We set the leading bit of $x$ to zero and compute a word consisting of as many concatenated copies of $x$ as there are fields left in $A$.
		
		\item
        We do parallel comparison between the remaining fields in $A$ and the word we computed just before.
        
        \item
        The result of rank$(x,A)$ is given by the number of fields whose leading bit was zero just before $A$ was shifted/masked plus the number of fields whose leading bit is zero after the parallel comparison.
    \end{enumerate}
    
\end{enumerate}

This operation takes $O(1)$ time, and we will run an example of this algorithm, explaining its intricacies.

\subsubsection{Parameters}

Since this algorithm branches depending on the leading bit of the query $x$, we will run the example with two queries $x_1$ and $x_2$ such that we explore both branches of the algorithm. Let $A$ be the concatenation of the keys of $S = \{0101_2, 0110_2, 1100_2, 1110_2 \}$. Note that if key $y_i < y_j$, then $y_i$ will be present in $A$ on a lesser significant position than $y_j$.
\begin{align*}
    A &= \underbrace{1110}_{A\langle 3 \rangle_4}\ \underbrace{1100}_{A\langle 2 \rangle_4}\ \underbrace{0110}_{A\langle 1\rangle_4}\ \underbrace{0101}_{A\langle 0 \rangle_4}{}_2 \\
    x_1 &= 1100_2 \\
    x_2 &= 0111_2 \\
    b &= 4 \\
    m &= 4
\end{align*}

\subsubsection{Step 1 --- Computing which fields have zero as their leading bit} \label{sec:computeM}

Since the keys in $A$ are sorted, we know that finding the position the least significant field whose first bit is one in $A$ will tell us how many fields there are with zero at their leading bit.

\begin{enumerate}
    \item
    We start by finding $M$. $M$ consists of a word with $m$ fields of $b$-bits, where each field is filled with zeroes excluding the least significant bit, which is set to one. In this particular example $M = 0001\ 0001\ 0001\ 0001_2$.
    
    \item % A & (M << (b - 1))
    We mask the non-leading bits of each field of $A$. This is achieved with:
    \begin{align*}
        A \wedge (M \ll (b - 1))
    \end{align*}
    
    Thus we have:
    \begin{align*}
        M &= 0001\ 0001\ 0001\ 0001_2 \\
        t_1 = M \ll (b - 1) &= 1000\ 1000\ 1000\ 1000_2 \\
        A &= \underline{1}110\ \underline{1}100\ \underline{0}110\ \underline{0}101_2 \\
        \cline{1-2}
        t_2 = A \wedge t_1 &= \underline{1}000\ \underline{1}000\ \underline{0}000\ \underline{0}000_2
    \end{align*}
    
    \item
    Computing lsb$(t_2)$ will give us the index of leading bit of the least significant field whose leading bit is one. Dividing the previous result by the field size $b$ will then give us the  field position results in total number of fields in $A$ whose leading bit is zero. In this particular example:
    \begin{align*}
        &\text{lsb}(t_2) = \text{lsb}(1000\ \underline{1}000\ 0000\ 0000_2) = 11 \\
        &t_3 = \frac{\text{lsb}(t_2)}{b} = \frac{11}{4} = 2 \\
    \end{align*}
\end{enumerate}

\subsubsection{Step 2 --- Computing the leading bit of the query}
In order to extract the value of the leading bit of our queries $x_1$ and $x_2$, we resort to the algorithm of section~\ref{sec:bit}. The leading bit of the query will be at position $b - 1$, thus we have for $x_1$:
\begin{align*}
    x_1 = \underline{1}100&_2\\
    \text{bit}(b - 1, x_1) = \text{bit}(3, x_1) = 1\\
\end{align*}
And for $x_2$:
\begin{align*}
    x_2 = \underline{0}111&_2\\
    \text{bit}(b - 1, x_2) = \text{bit}(3, x_2) = 0\\
\end{align*}

\subsubsection{Step 3 --- Computing rank with parallel comparison}

We will now run the algorithm for each of its branches. If the leading bit of the query if one, then we run the first branch; otherwise the second.
\begin{itemize}
    \item
    In this branch our query is $x_1 = 1100_2$:
    \begin{enumerate}
        \item
        Since the leading bit of our query $x_1$ is one, we know now that its rank in $A$ is at least the number of fields in $A$ whose leading bit is zero. So we proceed by removing those fields from $A$, and for this purpose we resort to the getFields$(i, f, A)$ defined in Section~\ref{sec:fieldRetrieval}. In our example:
        \begin{align*}
            A &= \underline{1110}\ \underline{1100}\ 0110\ 0101_2 \\
            t_3 &= 2 \\
            A := \text{getFields}(t_3, b, A) &= 0000\ 0000\ \underline{1110}\ \underline{1100}_2 \\
        \end{align*}
        
        \item
        We apply the same principle to the $M$ word by doing the very same operation as just before.
        \begin{align*}
            M &= \underline{0001}\ \underline{0001}\ 0001\ 0001_2 \\
            t_3 &= 2 \\
            \cline{1-2}
            M := \text{getFields}(t_3, b, M) &= 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
        \end{align*}
        
        \item
        We set the leading bit of $x_1$ to zero and multiply it by $M$ to produce a word containing concatenated copies of $x_1$.
        \begin{align*}
            x_1 = 1100_2 \\
            M = 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
            \cline{1-2}
            x_1 := \text{deleteBit}(b - 1, x_1) = 0100_2 \\
            \cline{1-2}
            x_1 := x_1 \times M = 0000\ 0000\ \underline{0100}\ \underline{0100}_2 \\
        \end{align*}
        
        \item
        The last ingredient needed for the parallel comparison is a mask comprised of a word whose leading bit of each field is one. Shifting $M$ by $b - 1$ positions to the left will produce such result.
        \begin{align*}
            M = 0000\ 0000\ 000\underline{1}\ 000\underline{1}_2& \\
            \cline{1-2}
            M := M \ll (b - 1) = 0000\ 0000\ \underline{1}000\ \underline{1}000_2& \\
        \end{align*}
        
        \item
        We take the difference between $A$ and $x$ and mask out the bits at all positions except the leading bits of each field in the resulting word.
        \begin{align*}
            A &= 0000\ 0000\ 1\underline{110}\ 1\underline{100}_2 \\
            x_1 &= 0000\ 0000\ 0\underline{100}\ 0\underline{100}_2 \\
            M &= 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
            \cline{1-2}
            A - x_1 &= 0000\ 0000\ \underline{1}???\ \underline{1}???_2 \\
            d_1 = (A - x_1) \wedge M &= 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
        \end{align*}
        
        \item
        To learn how many of the remaining of fields in $A$ that are smaller than $x_1$, we compute lsb($d_1$) and divide it by $b$.
        \begin{align*}
            d_1 = 0000\ 0000\ 1000\ \underline{1}000_2 \\
            \text{lsb}(d_1) = 3 \\
            b = 4 \\
            \cline{1-2}
            t_4 = \frac{\text{lsb}(d_1)}{b} = \frac{3}{4} = 0 
        \end{align*}
        
        \item
        Computing rank$(x_1, A)$ consists of returning the number of fields in $A$ that are strictly smaller than $x$. In this specific context, we know that all fields whose leading bit is zero are smaller than $x_1$, and we have also just computed the number of fields whose leading bit is one but that are still smaller than $x_1$. So we just add those results, and we have:
        \begin{align*}
            \text{rank}(x_1, A) &= t_3 + t_4 = 2 + 0 \\
            \text{rank}(x_1, A) &= 2
        \end{align*}
        
    \end{enumerate}
    \item
    In this branch our query is $x_2 = 0111_2$:
    \begin{enumerate}
        \item
        Since the leading bit of our query $x_2$ is zero, we can safely disregard the fields in $A$ whose leading bit is one. Similarly to what was done in the first branch, $M$ suffers a similar change, and we will start with that by using the getFields$(i, j, f, A)$ function defined in Section~\ref{sec:fieldRetrieval}. Thus we have:
        \begin{align*}
            M &= 0001\ 0001\ \underline{0001}\ \underline{0001}_2 \\
            t_3 &= 2 \\
            \cline{1-2}
            M := \text{getFields}(0, t_3, b, M) &= 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
        \end{align*}
        
        \item
        We need to have as many concatenated copies of $x_2$ as there are fields in $A$ whose leading bit is zero. So we multiply $M$ by $x_2$ and we end with:
        \begin{align*}
            x_2 = 0111_2 \\
            M = 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
            \cline{1-2}
            x_2 := x_2 \times M = 0000\ 0000\ \underline{0111}\ \underline{0111}_2 \\
        \end{align*}
        
        \item
        As before, we need a mask to perform the parallel comparison. So we use the same technique as in the other branch and shift $M$ by $b-1$ positions to the left:
        \begin{align*}
            M = 0000\ 0000\ 000\underline{1}\ 000\underline{1}_2& \\
            \cline{1-2}
            M := M \ll (b - 1) = 0000\ 0000\ \underline{1}000\ \underline{1}000_2& \\
        \end{align*}
        
        \item
        Lastly, for the last ingredient of the parallel comparison, we discard the fields in $A$ whose leading bit is one, and set the leading bit of remaining fields to one. Thus we have:
        \begin{align*}
            A = &\ 1110\ 1100\ \underline{0110}\ \underline{0101}_2 \\
            t_3 = &\ 2 \\ 
            M = &\ 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
            \cline{1-2}
            A := \text{getFields}(0, t_3, b, A) = &\ 0000\ 0000\ \underline{0110}\ \underline{0101}_2 \\
            \cline{1-2}
            A := M \vee A = &\ 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
            \vee &\ 0000\ 0000\ \underline{0}110\ \underline{0}101_2 \\
            \cline{1-2}
            A = &\ 0000\ 0000\ \underline{1}110\ \underline{1}101_2
        \end{align*}
        
        \item
        We take the difference between $A$ and $x_2$ and mask out the bits at all positions except the leading bits of each field in the resulting word.
        \begin{align*}
            A &= 0000\ 0000\ 1\underline{110}\ 1\underline{101}_2 \\
            x_2 &= 0000\ 0000\ \underline{0111}\ \underline{0111}_2 \\
            M &= 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
            \cline{1-2}
            A - x_2 &= 0000\ 0000\ \underline{0}???\ \underline{0}???_2 \\
            d_2 = (A - x_2) \wedge M &= 0000\ 0000\ \underline{0}000\ \underline{0}000_2 \\
        \end{align*}
        
        \item
        Note that $d_2$ is zero. Since there are no set bits in $d_2$ then $x_2$ is larger than all $x_2$ must be larger than all the remaining fields in $A$, so we just return $t_2$.
        \begin{align*}
            \text{rank}(x_2,A) &= t_3 = 2
        \end{align*}
        
    \end{enumerate}
\end{itemize}

\chapter{Implementation of theoretically optimal dynamic rank, select, and predecessor data structure}

% \subsection{Code base navigation}

All the implementing classes described in this section can be found in the {\ttfamily src\textbackslash java\textbackslash integersets} folder. The files names are self-explanatory, e.g., the {\ttfamily BinarySearchTrie.java} file implements the {\ttfamily BinarySearchTrie} whereas {\ttfamily RankSelectPredecessorUpdate.java} implements the {\ttfamily RankSelectPredecessorUpdate} interface.

\section{Utility functions}

This project features a class, {\ttfamily Util}, which implements static utility functions. Below find listed the functions included in this class, together with a brief explanation. The class also includes 32 and 64-bit versions for the input word, making the method signature different solely on the input word type.
For brevity, the 32-bit version is omitted.

\subsection{Bit operations}
The algorithms which these functions implement are described in Section~\ref{sec:bit}.
The functions included are:

\begin{itemize}
    \item
    The method below returns the value of the bit at position $d$ in $A$. It is enforced that $d \in [0, w[$.
    \begin{lstlisting}
public static int bit(final int d, final long A)
    \end{lstlisting}
    
    \item
    The method below sets the bit at index $d$ in $A$ to 1 and returns $A$ after the change. If the bit was already 1 or if the provided index $d \not\in [0, w[$, then the function has no effect.
    \begin{lstlisting}
public static int setBit(final int d, int A)
    \end{lstlisting}
    
    \item
    The method below sets the bit at index $d$ to 0 and returns $A$ after the change. If the bit was already 0 or if the provided index $d \not\in [0, w[$, then the function has no effect.
    \begin{lstlisting}
public static int deleteBit(final int d, int A)
    \end{lstlisting}
\end{itemize}

\subsection{Fields of words}
The algorithms which these functions implement are described in Section~\ref{sec:fieldsOfWords}.
The functions included are:

\begin{itemize}
    \item
    The method below returns $A\langle i\rangle_f$. It is enforced that $f \in [0, w]$ and $i \times f \in [0, w]$.
    \begin{lstlisting}
public static long getField(final int i, final int f, final long A)
    \end{lstlisting}
    
    \item
    The method below returns $A\langle i, j \rangle_{g \times f}$. It is enforced that $f \in [0, w]$, $g < f$ and $i \times g + j \in [0, w]$.
    \begin{lstlisting}
public static int getField2d(final int i, final int j, final int g, final int f, final int A)
    \end{lstlisting}
    
    \item
    The method below returns the range of fields $A\langle i \dots j \rangle_f$. It is enforced that $f \in [0, w]$, $i \times f \in [0, w]$, $j \times f \in [0, w]$, $i < j$, and $f \cdot (j - i) < w$.
    \begin{lstlisting}
public static long getFields(final int i, final int j, final int f, final long A)
    \end{lstlisting}
    
    \item
    The method below returns the range of fields $A\langle i \dots * \rangle_f$. It is enforced that $f \in [0, w]$ and $i \times f \in [0, w]$.
    \begin{lstlisting}
public static long getFields(final int i, final int f, final long A)
    \end{lstlisting}
    
    \item
    The method below sets $A\langle i \rangle_f := y$ and returns $A$ after the change. It is enforced that $f \in [0, w]$ and $i \times f \in [0, w]$. Only the bits in $y\langle 0 \rangle_f$ are considered.
    \begin{lstlisting}
public static int setField(final int i, final int y, final int f, final long A)
    \end{lstlisting}
\end{itemize}

\subsection{String representation of an integer in binary}

\begin{itemize}
    \item
    The method below returns a string representation of integer $x$ in binary prefixed by {\ttfamily 0b}, including leading zeros (and suffixed by {\ttfamily l} if it is a 64-bit integer).
    \begin{lstlisting}
public static String bin(final long x)
    \end{lstlisting}
    
    \item
    The method below returns a string representation of integer $x$ in binary prefixed by {\ttfamily 0b}, including leading zeros, spaced by {\ttfamily \_} every $f$ bits counting from the least significant bit (and suffixed by {\ttfamily l} if it is a 64-bit integer).
    \begin{lstlisting}
public static String bin(final long x, final int f)
    \end{lstlisting}
\end{itemize}

\subsection{Helper functions}

\begin{itemize}
    \item
    The method below implements a helper function for the {\ttfamily rankLemma1} method, returning the index of the transition from zero to one in $field$, e.g., which powers of two are smaller than the input $field$.
    \begin{lstlisting}
private static int parallelComparison(final long cluster)
    \end{lstlisting}

    \item
    This method is a helper function for the {\ttfamily parallelComparison} method, and simply returns the value associated with a given $pow$ in a small lookup table.
    \begin{lstlisting}
private static int parallelLookup(final int pow)
    \end{lstlisting}
    
    \item
    The method below is a helper method for the most significant set bit lookup functions, as described in \cite{bittricks}\footnote{The following link redirects you to the function I took inspiration from: \url{https://graphics.stanford.edu/~seander/bithacks.html\#IntegerLogLookup}} and mentioned below. It populates a lookup table, allowing these functions to return the result quickly. 
    \begin{lstlisting}
private static void generateLookupTable()
    \end{lstlisting}
\end{itemize}

\subsection{Most and least significant set bit}

The algorithms which these functions implement are described in Sections~\ref{sec:msbAlgorithm} and \ref{sec:lsbAlgorithm}.
The functions included are:

\begin{itemize}
    \item
    The method below returns the index of the most significant set bit of the target $x$. It is used as a subroutine in many other functions. The actual operation used to compute the result can be easily changed in the body of the method by altering the function that is called. The version featured with this report calls {\ttfamily msbConstant}, defined a few bullet points below.
    \begin{lstlisting}
public static int msb(final long x)
    \end{lstlisting}
    
    \item
    The method below returns the index of the least significant set bit of $x$.
    \begin{lstlisting}
public static int lsb(final long x)
    \end{lstlisting}
    
    \item
    The method below returns the index of the most significant set bit of $x$ by calling a Java standard library function and computing the result with an expression.
    \begin{lstlisting}
public static int msbLibrary(final long x)
    \end{lstlisting}
    
    \item
    The method below implements a naive algorithm for computing the index of the most significant set bit of the target $x$, as described in \cite{bittricks}\footnote{The following link redirects you to the function I took inspiration from: \url{https://graphics.stanford.edu/~seander/bithacks.html\#IntegerLogObvious}}.
    \begin{lstlisting}
public static int msbObvious(long x)
    \end{lstlisting}
    
    \item
    The method below implements a lookup algorithm for computing the index of the most significant set bit of the target $x$, as described in \cite{bittricks}\footnote{The following link redirects the reader to the function I took inspiration from: \url{https://graphics.stanford.edu/~seander/bithacks.html\#IntegerLogLookup}}. For 64-bit integers, the function first splits the integer in two, calling the 32-bit method on the high half first, and then on the second in the first half is zero.
    \begin{lstlisting}
public static int msbLookupDistributedInput(final long x)
    \end{lstlisting}

    \item
    The method below implements the algorithm from Section~\ref{sec:msbO1}, which follows the lecture noted from \cite{erikdemainelec12} and \cite{nelsonjelanilec2}.
    \begin{lstlisting}
public static int msbConstant(long x)
    \end{lstlisting}
    
\end{itemize}

\subsection{Rank Lemma 1}

The method below implements rank$(x,A)$ from Section~\ref{sec:rankLemma1}.
\begin{lstlisting}
public static int rankLemma1(long x, long A, final int m, final int b)
\end{lstlisting}
The input parameters are:
\begin{itemize}
    \item
    A query $x$, the integer to find the rank in $A$.
    
    \item
    A word $A$, containing keys with the same size as $x$, which must be sorted for the method to return a sound result.
    
    \item
    The number of keys in $A$, $m$.
    
    \item
    The length of each key in $A$, $b$, in bits.
\end{itemize}

\subsection{Additional Utility Functions}

\begin{itemize}
    \item
    The method below takes a 64-bit integer $x$ and returns a two-entry array, each position containing 32 of the 64 bits of $x$. The least significant bits of $x$ will be at index 0, whereas the most significant bits will be at position 0.
    \begin{lstlisting}
public static int[] splitLong(final long x)
    \end{lstlisting}
    
    \item
    The method below computes the reverse of the method just above. It takes a 32-bit integer array and combines its first two positions into a single 64-bit integer. Again, position 0 of the input array is used for the least significant bits of the resulting 64-bit integer, whereas position one will populate the remaining 32 most significant positions.
    \begin{lstlisting}
public static long mergeInts(final int[] x)
    \end{lstlisting}
    
    \item
    The helper method below produces a word comprised of $w / b$ fields of $b$ bits in length, having each field its least significant bit set to 1. E.g., the resulting word will have the bits at index zero and every $b$-th index set to 1.
    \begin{lstlisting}
public static long M(final int b, final int w)
    \end{lstlisting}

    \item
    The helper method below returns a string representation of interpreting the matrix stored in the word $A$, with $\#rows$ rows and $\#columns$ columns.
    \begin{lstlisting}
public static String matrixToString(final int rows, final int columns, final long A)
    \end{lstlisting}
\end{itemize}

\section{The {\ttfamily RankSelectPredecessorUpdate} interface}

As stated in Section~\ref{sec:predecessorProblem}, the data structure presented in \cite{patrascu2014dynamic} solves the dynamic predecessor problem. For this reason, an interface denoted {\ttfamily RankSelectPredecessorUpdate} was implemented with the method signatures and default methods:
\begin{itemize}
    \item
    The $insert(x)$ operation sets $S=S \cup \{x\}$ and it is to be implemented by a method with the signature:
    \begin{lstlisting}
void insert(long x);
    \end{lstlisting}
    
    \item
    The $delete(x)$ operation sets $S=S \setminus \{x\}$ and is to be implemented by a method with the signature:
    \begin{lstlisting}
void delete(long x);
    \end{lstlisting}
    
    \item
    The $member(x)$ operation returns $[x \in S]$ and it is implemented as a default method, making all implementing classes automatically inheriting the method:
    \begin{lstlisting}
default boolean member(final long x) {
    if (isEmpty()) {
        return false;
    }
    final Long res = successor(x);
    return res != null && res == x;
}
    \end{lstlisting}

    \item
    The $predecessor(x)$ operation returns $max\{y\in S\ |\ y < x\}$ and it is implemented as a default method, making all implementing classes automatically inheriting the method:
    \begin{lstlisting}
default Long predecessor(long x) {
    return select(rank(x) - 1);
}
    \end{lstlisting}

    \item
    The $successor(x)$ operation returns $min\{y\in S\ |\ y \geq x\}$ and it is implemented as a default method, making all implementing classes automatically inheriting the method:
    \begin{lstlisting}
default Long successor(long x) {
    return select(rank(x));
}
    \end{lstlisting}

    \item
    The $rank(x)$ operation returns $\#\{ y \in S\ |\ y < x\}$ and it is to be implemented by a method with the signature:
    \begin{lstlisting}
long rank(long x);
    \end{lstlisting}

    \item
    The $select(i)$ operation returns $y \in S$ with $rank(y) = i$ and it is to be implemented by a method with the signature:
    \begin{lstlisting}
Long select(long rank);
    \end{lstlisting}
\end{itemize}
Additionally, the following method signatures are included in the interface:
\begin{itemize}
    \item
    A {\ttfamily size()} method that returns the current number of keys in the set:
    \begin{lstlisting}
long size();
    \end{lstlisting}

    \item
    An {\ttfamily isEmpty()} default method that returns {\ttfamily true} if the set is empty and {\ttfamily false} otherwise:
    \begin{lstlisting}
default boolean isEmpty() {
    return size() == 0;
}
    \end{lstlisting}

    \item
    A {\ttfamily reset()} method that removes all current elements from the set:
    \begin{lstlisting}
void reset();
    \end{lstlisting}
\end{itemize}

Note that some of the methods return a primitive type, whereas some others return a boxed type. This is because some queries are not mapped to any answer, and the boxed type provides the perfect way to model this kind of scenario: in such a situation, {\ttfamily null} is returned.

\section{Naive implementation}
We start with a naive implementation of name {\ttfamily NaiveDynamicFusionNode}. It holds a $key$ array to store the keys, and a counter for the current number of keys in the data structure. The keys can be any 64-bit integer.

The basic idea behind this implementation is to store the keys in $key$, making their respective rank the same as their index in that array. In other words, $key$ is always sorted.

Updates, e.g., insert and delete, take $O(n)$ time. This is because whenever a key is inserted, its rank $i$ is found, and the key at that position as well as all following keys up to $n-1$ are updated. Since any given key index in $key$ is its rank, all the keys with rank larger than the new key have to be moved one position to the right in $key$ to make room for the new key and keeping rank consistent.

A rank query takes $O(\log_2(n))$ because a binary search is performed on $key$. Select is faster: $O(1)$, because we need only to access and return the key at position $i$ in $key$ to fulfill the query.

\section{Dynamic Fusion Node with binary search for Rank} \label{sec:DynamicFusionNodeBinaryRank}
We take a step forward by improving the previous idea: this time, two additional words, $index$ and $bKey$, are kept in the fields. The goal is to use the concepts described in the \textit{Indexing} chapter of \cite{patrascu2014dynamic} to implement this data structure. The running times will be $O(\log_2 n)$ for updating and querying, and this is because the $rank$ operation resorts to binary search to produce the result.

We interpret $bKey$ as an array where the values first $k$ bits correspond to the positions in $key$. Like any other word, the bits in $bKey$ are indexed from $0$ to $k-1$, and if the $i^{th}$ bit is set to $1$, then position $i$ in $key$ is free to store a key, and vice-versa.

We interpret {\ttfamily index} as an array of $k$ entries, each taking $\lceil \log_2(k) \rceil$ bits. In order to maximize the use of the number of bits in $index$, and knowing that our program is working with 64-bit integers, we can solve the following equation:
\begin{equation}
    k \cdot log_2(k) = 64 \iff k = 16
\end{equation}
If $k=16$, then $\lceil \log_2(k) \rceil = 4$. Each $\lceil \log_2(k) \rceil$-bit field of {\ttfamily index} stores the index of the key in {\ttfamily key} in their sorted order.
It is important to note that \cite{patrascu2014dynamic} mentions only that $k$ has to be a power of two. The implementation allows for $k$ to take other values just as long as they are smaller than $16$ and a power of two.

\subsection{Fields}
The class holds the following fields:
\begin{itemize}
    \item
    The parameter $k$, accompanied with the constant $\lceil \log_2(k) \rceil$:
    \begin{lstlisting}
private static final int k = 16;
private static final int ceilLgK = (int) Math.ceil(Math.log10(k)/Math.log10(2));
    \end{lstlisting}

    \item
    The array of keys, $key$:
    \begin{lstlisting}
    private final long[] key = new long[k];
    \end{lstlisting}
    
    \item
    The $index$ word:
    \begin{lstlisting}
private long index;
    \end{lstlisting}

    \item
    The map of over empty entries in $key$, $bKey$:
    \begin{lstlisting}
private int bKey;
    \end{lstlisting}
    Note that only the first $k$ bits are relevant for any given instance.
    
    \item
    An integer $n$, containing the current number of keys in the set:
    \begin{lstlisting}
private int n;
    \end{lstlisting}
\end{itemize}

\subsection{Helper methods}
\begin{itemize}
    \item
    {\ttfamily firstEmptySlot()} returns the first available spot in $key$ by computing lsb$(bKey)$. Since only the first $k$ spots are valid results, a check is done to see if this result is within the range, returning $-1$ if not.
    
    \item
    {\ttfamily fillSlot(final int j)} sets position $j$ in $bKey$ to not empty. This is done with a call to {\ttfamily deleteBit(j, bKey)}.
    
    \item
    {\ttfamily vacantSlot(int j)} sets the $j^{th}$ position of $bKey$ to empty by calling {\ttfamily setBit(j, bKey)}.
    
    \item
    {\ttfamily getIndex(final long i)} returns the index in $key$ of the key with rank $i$. This operation is done with a call to {\ttfamily getField(i, ceilLgK, index)}.
    
    \item
    The purpose of the overloaded method {\ttfamily updateIndex} is to maintain the correspondence between the rank of the keys in the set and their position in $key$.
    The version with {\ttfamily updateIndex(final int i)} signature removes rank $i$ from $index$, whereas the {\ttfamily updateIndex(final int i, final int slot)} inserts in $index$ at position $i$ the index in $key$ (here denoted by $slot$). Both versions make calls to the {\ttfamily getFields} methods with the adequate parameters, merge the results with bit-wise $\vee$ and write those back in $index$.
    
    \item
    {\ttfamily binaryRank(final long x)} returns the rank of $x$ in the set, using {\ttfamily select(final long rank)} as a subroutine. As the name implies, the algorithm used in this implementation is binary search.
\end{itemize}

\subsection{Implementation of the interface methods} \label{sec:binaryRankInterfaceImplementation}
\begin{itemize}
    \item
    {\ttfamily insert(final long x)}:
    \begin{enumerate}
        \item
        If the $x$ is already in the set, or if the node has reached its limit ($k$), the method does not progress.
        
        \item
        The rank of the $x$ in the set is found with a call to {\ttfamily rank(x)} and stored in a local variable $i$.
        
        \item
        The first available spot in $key$ is found with a call to {\ttfamily firstEmptySlot()} and stored in a local variable $j$.
        
        \item
        We store $x$ in $key$ at the position returned by {\ttfamily firstEmptySlot()}.
        
        \item
        We set the position taken $x$ in $key$ to not empty by calling {\ttfamily fillSlot(j)}.
        
        \item
        We update the $index$ to reflect the new key's insertion with a call to {\ttfamily updateIndex(i, j)}.
        
        \item
        Lastly, we increment $n$ by one, updating the current total number of keys in the set.
    \end{enumerate}
    
    \item
    {\ttfamily delete(final long x)}:
    \begin{enumerate}
        \item
        If the $x$ is not in the set, the method does not progress. This is done with a call to {\ttfamily member(x)}.
        
        \item
        The rank of the $x$ in the set is found with a call to {\ttfamily rank(x)} and stored in a local variable $i$.
        
        \item
        $bKey$ is updated by making the spot taken by $x$ in $key$ empty. This is done with the call {\ttfamily vacantSlot(getIndex(i))}.
        
        \item
        We update the $index$ to reflect the deletion of $x$ with a call to {\ttfamily updateIndex(i)}.
        
        \item
        Lastly, we decrement $n$ by one, updating the current total number of keys in the set.
    \end{enumerate}
    
    \item
    {\ttfamily rank(final long x)} returns the rank of $x$ in the set by calling the {\ttfamily binaryRank(final long x)} helper method.
    
    \item
    {\ttfamily select(final long rank)} starts by checking if the $rank$ is within range, returning {\ttfamily null} if not. Then it calls {\ttfamily getIndex(rank)} and returns the key at that position in $key$.
    
    \item
    {\ttfamily size()} returns the value of $n$.
    
    \item
    {\ttfamily reset()}.
    Resetting the set is easily done by setting $n$ to zero and $bKey$ to $-1$ (because $-1$ has all the bits set to one in its two's complement binary representation).
\end{itemize}

\section{Rank via matching with "Don't Cares"}

Static fusion trees have less than optimal update time because adding a new key entails recomputing sketches. Pătrașcu and Thorup address this by introducing "don't cares", which provide a simulation of a Patricia trie at the node level. This is relevant because, differently to what happens at the fusion tree node from Fredman and Willard, inserting a new key in a Patricia trie corresponds to adding a new branch node \cite{patrascu2014dynamic}.

In order to make the algorithm work, taking one step beyond the static fusion node from Fredman and Willard, this algorithm uses the following:
\begin{itemize}
    \item
    Compressing keys/sketching in the same style as fusion trees.
    
    \item
    Encoding the information about "don't cares".
    
    \item
    Computing the rank of compressed keys via Rank Lemma 1 (defined in Section~\ref{sec:rankLemma1}).
\end{itemize}

The sketches and the information regarding "don't cares" will be stored in two words, {\ttfamily branch} and {\ttfamily free}. These are to be updated every time the node is updated.

Separate the compression function from the overall function. So, have a function compressNaive(x) that computes hat(x) (the compressed version or sketch of x). This function is currently implemented inefficiently (probably by iterating over all set bits in the word that tells you which indices are significant) and will only be made dynamic in Sec 3.2-4. In the meantime, leave it as is and treat it as a black box.

\begin{enumerate}
    \item
    Sketching:
    For a given node, compute the "significant" bit indices. A "significant" bit index is the most significant bit of the XOR of two keys. A naive algorithm is to XOR all the combinations of keys and compute the their msb, have a local variable where we set the bits we find to be significant, which we can then read from.
    
    \item
    Don't cares:
    We assume keys to be sorted and compressed, for instance in an array (done in the previous step)
    The algorithm consists of the following recursion:
    \begin{enumerate}
        \item
        Starting from the most significant bit of the sketch, if all bits are the same in all keys, then that position is a don't care for all keys
        
        \item
        If one or more bits differ at that position, we care for that position.
        
        \item
        Recurse, grouping the sketches that have the same bit at the position we looked that.
    \end{enumerate}
    
    \item
    We now have the sketches and we also know which positions are the don't cares. We need now to store this information in BRANCH and FREE. Given a key y, and we know its rank i in S (the node), at every "significant" position h:
    \begin{itemize}
        \item
        If h is not a don't care, we store the bit of that position of y at position $\langle i,h\rangle_{k\times1}$ of BRANCH, and we set $\langle i,h\rangle_{k\times1}$ of FREE to zero.
        
        \item
        Otherwise, h is a don't care, so we set $\langle i,h\rangle_{k\times1}$ of BRANCH to zero and $\langle i,h\rangle_{k\times1}$ of FREE to 1.
    \end{itemize}
    Note how subtle this is: we store exactly as many positions per key as we have keys in the set, hence the k*k, and hence why here a field in both BRANCH and FREE is of length k*1.
    Now some math, $k^2$ must fit in 64 bits, and k must also be a power of 2: sqrt(64) = 8 which is also a power of 2. So here we have another constraint in regards to k, which until now could be up to 16, now it can only be 8.
    
    \item
    We define a subroutine match(x), which uses rank lemma 1 (expression is on page 9)
    
    \item
    Having match defined, we can compute the overall rank algorithm, which is also given the steps in the paper.
\end{enumerate}

\subsection{Key compression with "don't cares"}

\begin{figure}[h!]
\centering
\begin{tikzpicture}
  [level distance = 12mm,
   sibling distance = 30mm,
   dot/.style = {circle, fill, minimum size=1mm, inner sep=2pt}
  ]
  
  \node[dot] {}
    child{node[dot] {} 
      child[missing] {} % left child
      child{node[dot] {}
        child{node[dot] {}
          child{node[dot] {}
            child{node[dot] {}
              child{node(x1)[dot] {}
                edge from parent node(lvl6_1) [left=3pt] {$0$}
              }
              child{node(x2)[dot] {}
                edge from parent node(lvl6_2) [right=3pt] {$1$}
              }
              edge from parent node(lvl5_1) [left=3pt] {$0$}
            }
            child{node[dot] {}
              child[missing] {}
              child{node(x3)[dot] {}
                edge from parent node(lvl6_3) [right=3pt] {$1$}
              }
              edge from parent node(lvl5_2) [right=3pt] {$1$}
            }
            edge from parent node[left=3pt] {$0$}
          }
          child[missing] {}
          edge from parent node(lvl3_1) [left=3pt] {$0$}
        }
        child{node[dot] {}
          child{node[dot] {}
            child[missing] {}
            child{node[dot] {}
              child[missing] {}
              child{node(x4)[dot] {}
                edge from parent node(lvl6_4) [right=3pt] {$1$}
              }
              edge from parent node(lvl5_3) [right=3pt] {$1$}
            }
            edge from parent node[left=3pt] {$0$}
          }
          child[missing] {}
          edge from parent node(lvl3_2) [right=3pt] {$1$}
        }
        edge from parent node[right=3pt] {$1$}
      }
      edge from parent node[left=3pt] {$0$}
    }
    child[missing] {};

  \node[draw = black, inner sep = 0pt, thick, ellipse, fit = (lvl3_1) (lvl3_2)] {};
  \node[draw = black, inner sep = 0pt, thick, ellipse, fit = (lvl5_1) (lvl5_2) (lvl5_3)] {};
  \node[draw = black, inner sep = 0pt, thick, ellipse, fit = (lvl6_1) (lvl6_2) (lvl6_3) (lvl6_4)] {};
  
  \node(labelx1) [below=10pt of x1] {$01\underline{0}0\underline{0}\underline{0}$};
  \node(labelx1_2) [below=10pt of labelx1] {$000$};

  \node(labelx2) [below=10pt of x2] {$01\underline{0}0\underline{0}\underline{1}$};
  \node[below=10pt of labelx2] {$001$};

  \node(labelx3) [below=10pt of x3] {$01\underline{0}0\underline{1}\underline{1}$};
  \node[below=10pt of labelx3] {$011$};

  \node(labelx4) [below=10pt of x4] {$01\underline{1}0\underline{1}\underline{1}$};
  \node[below=10pt of labelx4] {$111$};

  \node(legend) [left=10pt of labelx1_2] {$sketch(x_i)$:};
  \node[above=10pt of legend] {$x_i$:};  
\end{tikzpicture}
\caption{An example of the $sketch$ function with $4$ keys. The levels 
corresponding to the $3$ bits sketched are circled.}
\label{fig1}
\end{figure}


make one example of match, compressing keys and the table from the paper. explain why match works and what exactly it means.


\textbf{RUN THE ALGORITHM WITH AN EXAMPLE; AS I'VE DONE IN PREVIOUS SECTIONS}

\subsection{Fields}

This class shares many implementation details with the Dynamic Fusion Node with binary Rank from Section~\ref{sec:DynamicFusionNodeBinaryRank}. For that reason, below we will only see what has been added or altered in comparison with that implementation. These changes help enabling the new operations now implemented in the class:
\begin{itemize}
    \item
    The parameter $k$ has been altered. This is because the implementation requires us to maintain some other variables that will limit the capacity of the set:
    \begin{lstlisting}
private static final int k = 8;
    \end{lstlisting}
    
    \item
    We will need a constant $M$ to be used as mask in some of methods. We resort to the {\ttfamily M} function of the {\ttfamily Util} class, and store the result as a class variable. 
    \begin{lstlisting}
private static final long M = Util.M(k, k * k);
    \end{lstlisting}

    \item
    The operations introduced in this implementation require us to compress keys. To this extent, we store a word, $compressingKey$ which will retain the information regarding the bits to keep when compressing a $key$. If a bit is to be kept, then it will be set to one in $compressingKey$.
    \begin{lstlisting}
private long compressingKey;
    \end{lstlisting}
    
    \item
    The word $compressedKeys$ stores the compressed keys that are in the set. Each of its $compressedKeys\langle i \rangle_k$ contains the compressed key of rank $i$ in the set.
    \begin{lstlisting}
private long compressedKeys;
    \end{lstlisting}

    \item
    The word $dontCares$ stores the information regarding the "don't cares" of each of the keys in the set. It is designed in the same fashion as $compressedKeys$, Each of its $compressedKeys\langle i \rangle_k$ contains the compressed key of rank $i$ in the set.
    \begin{lstlisting}
private long dontCares;
    \end{lstlisting}
    
    \item
    The word $compressedKeys$ stores the compressed keys that are in the set. Each of its $compressedKeys\langle i \rangle_k$ contains the compressed key of rank $i$ in the set.
    \begin{lstlisting}
private long branch;
    \end{lstlisting}
    
    \item
    The word $compressedKeys$ stores the compressed keys that are in the set. Each of its $compressedKeys\langle i \rangle_k$ contains the compressed key of rank $i$ in the set.
    \begin{lstlisting}
private long free;
    \end{lstlisting}
\end{itemize}



\subsection{Helper methods}

\subsection{Implementation of the interface methods}

\section{Dynamic Fusion Node with constant time Rank}
BRANCH and FREE

\section{Inserting while maintaining BRANCH and FREE}

The algorithm for inserting a key {\ttfamily x} in the set while maintaining {\ttfamily branch} and {\ttfamily free}, e.g. the compressed sketches of keys with "don't cares", is comprised of the following steps:
\begin{itemize}
    \item
    If the set is empty, we simply insert the key as described in steps 2-6 of {\ttfamily insert} in Section~\ref{sec:binaryRankInterfaceImplementation}.
    
    \item
    Otherwise:
    \begin{enumerate}
        \item
        We compute {\ttfamily match(x)} and store it in a local variable $i$.
        
        \item
        We query {\ttfamily select(i)} and 
        
    \end{enumerate}
\end{itemize}

\chapter{Correctness tests}

\section{{\ttfamily Util} class tests}

All the tests concerning the {\ttfamily Util} class can be found in the {\ttfamily UtilTest} class in the {\ttfamily src\textbackslash test\textbackslash java} folder.

\subsection{msb series tests}

The {\ttfamily Util} class contains many different implementations of the msb$(x)$ operation. Since Java's standard library offers a {\ttfamily numberOfLeadingZeros} function, we can easily test the different msb$(x)$ implementations. Converting the result from the standard library function is done by subtracting its return value to $w - 1$.

Taking as an example the test on the {\ttfamily msbConstant()} implementation, for such a test to pass all instances in a given range have to assert that {\ttfamily Long.SIZE - 1 - Long.numberOfLeadingZeros(i)} and {\ttfamily Util.msbConstant(i)} are the same. Tests on the other implementations differ only either on $w$ (which can be either 32-bit {\ttfamily Integer} or 64-bit {\ttfamily Long}) and the function that is called, and each of them is named after the function they are testing, e.g. {\ttfamily msb32Obvious()} tests the 32-bit version the naive msb$(x)$ algorithm.

\subsection{{\ttfamily splitLong} and {\ttfamily mergeInts}}

The {\ttfamily splitMerge()} method tests the {\ttfamily splitLong} and {\ttfamily mergeInts} methods by evaluating if the following property holds for a determined range of 64-bit keys: {\ttfamily key == mergeInts(splitLong(key))}.

\subsection{Fields of words tests}
The {\ttfamily getField} and {\ttfamily setField} methods are tested in the {\ttfamily setAndGetField32()} and {\ttfamily setAndGetField64()} methods (the latter differ solely on the size of the word where the fields are to be written to). A pass of the test consists of:
\begin{enumerate}
    \item
    Varying $f$ (being $f$ the size of each field) between one and $w - 1$.
    
    \item
    For each value $f$ takes, the number of fields to be stored in $A$, $m$, is computed as a function of $f$. The goal is to fit as many fields as possible in $A$, having $f$ and $w$ as constraints. This is done with the expression $m = w / f$.
    
    \item
    Then, $m$ keys of $f$ size are pseudo-randomly generated. Each time a key is generated, $A$ is shifted to the left by $f$ bits, and the key is stored both in an auxiliary array and in $A$ with the {\ttfamily setField} function. 
    
    \item
    When all $m$ keys have been generated and inserted, the auxiliary array is iterated, and at each iteration $i$, it asserts that the key at index $i$ in the auxiliary array is the same as the one returned by the {\ttfamily getField} function.
\end{enumerate}

\subsection{Test for Rank Lemma 1}
The {\ttfamily rankLemma1} function is tested in a method with the same name.
A pass in this test consists of:
\begin{enumerate}
    \item
    Varying $b$ (size in bits of each key). This range is specified in the fields of the {\ttfamily UtilTest} class.
    
    \item
    For each value $b$ takes, the number of keys to be stored in $A$, $m$, is computed by taking the minimum between $2^b$ and $w/b$. This is because the method requires that all keys stored in $A$ must be distinct (and all combinations of keys of size $b$ are given by $2^b$), but also $A$ can only store up to $w/b$ keys.
    
    \item
    We produce $m$ distinct keys by using a pseudo-random generator and inserting them in a set. We stop once the size of the set is $m$.
    
    \item
    An additional key $x$ is generated. The rank of $x$ will be computed and used later as one of the last checks of this test.
    
    \item
    The keys are then copied to a list, where they are sorted in descending order.
    
    \item
    The list is then iterated from the largest key to the smallest. Each iteration consists of inserting the current key in $A$. That key is also compared with $x$ in order to compute the rank of $x$, which is determined by the index of the current key in the list.
    
    \item
    The list is iterated once more in order to assess if the rank of each key in the list agrees with the rank computed with {\ttfamily rankLemma1} function.
    
    \item
    Lastly, the rank of $x$, which has been computed before, is compared with its rank computed via the {\ttfamily rankLemma1} function.
\end{enumerate}

\section{Integer Data Structure tests}

Each implementation of {\ttfamily RankSelectPredecessorUpdate} has a corresponding test class, which in turn has {\ttfamily Test} appended to its name. For example, the {\ttfamily BinarySearchTrie} test class is called {\ttfamily BinarySearchTrieTest} and it can be found in the {\ttfamily src\textbackslash test\textbackslash java} folder.

\subsection{Test parameters}

Each test class creates an instance of {\ttfamily RankSelectPredecessorUpdateTest} whose methods take a concrete implementation of {\ttfamily RankSelectPredecessorUpdate} to be tested. The constructor takes the following parameters:

\begin{itemize}
    \item {\ttfamily long seed}. This seed is used as a parameter for instantiating a pseudo-random generator from the Java standard library --- {\ttfamily java.util.Random}. This instance will be later used to produce data for the test cases, such as seeds for passes (explained below), which in turn will produce keys to be used in the tests.
    \item {\ttfamily int passes}. Some tests can be executed in more than one pass. A pass in a particular test consists of generating data with its corresponding seed and running the test with that data. When $passes > 1$, then different seeds are generated, which will result in different pseudo-random values, and the test is run {\ttfamily passes} number of times.
    \item {\ttfamily int numKeys}. This parameter defines the size of the data set to be generated. It is particular important for testing for instance {\ttfamily DynamicFusionNode}, which size cannot exceed $k$.
\end{itemize}

\subsection{{\ttfamily insertAndMemberSmallTest()}}
The methods tested in this test are {\ttfamily insert} and {\ttfamily member}. A small set of predetermined keys is inserted in the set, and then {\ttfamily member} is called on the set with each of those keys. 

\subsection{{\ttfamily smallCorrectnessTest()}}

An instance of a {\ttfamily RankSelectPredecessorUpdate} implementation is instantiated and keys are inserted such that after these insertions $S = \{10, 12, 42, -1337, -42\}$.

It is defined that:
\begin{itemize}
    \item
    Select queries can range between $0$ and $|S|-1$. Should any query fall outside this range, then {\ttfamily null} is returned, meaning, no result.
    \item
    $Select(0) = min\{y \in S \}$.
    \item
    $Select(|S|-1) = max\{y \in S\}$.
    \item
    Rank queries be any $w$-bit integer, and their possible range of results $\big[ 0, |S| \big]$
    \item
    Any given predecessor query returns the largest key in the subset of keys that are \textbf{strictly} smaller than the query, otherwise {\ttfamily null}.
    \item
    Whereas a successor query returns the queried key if present, otherwise the smallest key in the subset of keys that are larger than the query if any (and in such case {\ttfamily null} is returned).
\end{itemize}

With the given set and the above-mentioned rules, a small test is performed. Table~\ref{tab:smallCorrectnessTests} shows the expressions to be evaluated, and all of them must evaluate to {\ttfamily true} for the test to pass.

\begin{table}[H]
\centering
\input{src/tex/04_Tables/002_CorrectnessTestSmall}
\caption[Small correctness tests]{Small correctness tests.}
\label{tab:smallCorrectnessTests}
\end{table}


\subsection{{\ttfamily insertThenMemberTest()}}

The methods tested in this test are {\ttfamily insert} and {\ttfamily member}, and it can be executed in passes. It consists of:
\begin{enumerate}
    \item
    Iterating through all the pseudo-randomly-generated keys and inserting them all in the instance to be tested.
    \item
    Iterating in random order through all the keys and asserting $key \in S$.
\end{enumerate}

\subsection{{\ttfamily insertThenDeleteRangeOfKeysTest()}}

The methods tested in this test are {\ttfamily insert} and {\ttfamily member}. It consists of iterating the whole range (which goes from $0$ to {\ttfamily numKeys}), where each iteration {\ttfamily i} consists of:
\begin{enumerate}
    \item
    Asserting that the key, {\ttfamily i} is not in the set by calling {\ttfamily member} on the set with the key.
    \item
    Inserting the key {\ttfamily i} in the set.
    \item
    Asserting that the key {\ttfamily i} is in the set.
\end{enumerate}
Should the number of keys exceed 9, then every $1/10$ of {\ttfamily numKeys} the data structure is reset, and all keys are removed.

\subsection{{\ttfamily insertThenDeleteRandomKeysTest()}}

The methods tested in this test are {\ttfamily insert} and {\ttfamily delete}, and it can be executed in passes. After inserting all the pseudo-randomly-generated keys in the set, the keys are iterated in random order. Each iteration consists of:
\begin{enumerate}
    \item
    Asserting that $key \in S$.
    \item
    Removing the key.
    \item
    Asserting that $key \not\in S$.
\end{enumerate}

\subsection{{\ttfamily deleteTest()}}

This test aims at asserting that only when deleting an existing key, the cardinality of the set is altered. It tests the methods {\ttfamily delete} and size, and it can be executed in passes. At each pass:
\begin{enumerate}
    \item
    Pseudo-random keys are generated and delete on the set is called with that key.
    \item
    If the key was in the set, then the size must have decreased; otherwise, it must remain the same.
\end{enumerate}

\subsection{{\ttfamily sizeTest()}}

The methods tested in this test are {\ttfamily insert}, {\ttfamily size} and {\ttfamily delete} and it can be executed in passes. Each pass consists of:
\begin{enumerate}
    \item
    Iterating the pseudo-randomly-generated keys in random order. At each iteration, the key is inserted, and it is asserted that {\ttfamily size} has increased by 1.
    \item
    After all the keys have been inserted, the keys are iterated in random order once more, and at each iteration, the key is removed, and it is asserted that {\ttfamily size} has decreased by 1.
\end{enumerate}

\subsection{{\ttfamily growingRankTest()}}

This test aims at ensuring that the following property holds for all the keys in the set: the rank of keys in sorted order is a monotone increasing function. It can be executed in passes, and it works the following way:
\begin{itemize}
    \item
    After inserting all the keys in the set, a copy of those keys is kept on a {\ttfamily TreeSet} (a set that keeps its values in sorted order) such that we can iterate them in their sorted order.
    \item
    A counter {\ttfamily i} is kept and initialized as $0$. It is incremented at each iteration.
    \item
    The test then asserts that the key's rank is the same as the number of the current iteration. Note that we can assume that this condition must hold because the keys are iterated in sorted order. 
\end{itemize}

\subsection{{\ttfamily selectOfRankTest()}}

This test aims at ensuring that the following property holds for all the keys in the set: if a key is present in the set, knowing its rank and them querying for select of that must return the key. It can be executed in passes, and it works by iterating through the pseudo-randomly-generated keys, and at each iteration, it is asserted that {\ttfamily key == select(rank(key))}.

\subsection{{\ttfamily rankOfSelectTest()}}

This test aims at ensuring that the following property holds for all the keys in the set: the rank of select a query is the query. It can be executed in passes, and it works by iterating from {\ttfamily 0} to {\ttfamily numKeys}. At each iteration {\ttfamily i}, it is asserted that {\ttfamily i == rank(select(i))}.