\part{Implementation}

% \addsec{Unnumbered level}

% \section{First level}
% \subsection{Second level}
% \subsubsection{Third level}
% \paragraph{Forth level}
% \subparagraph{Fifth level}

% \subsection{Dummy subsection}

% This is some text to showcase the features of this thesis template. For example, it is possible to add a side note with\myMarginnote{I am a side note!}.

% In this paragraph, I will add an image as a template:
% \begin{figure}[H]
% \centering
% 	\includegraphics[width=0.9\textwidth]%
% 	{03_GraphicFiles/CowLickingNose.jpg}%
% \caption[A cow]{A cow licking its nose. Usage with permission of the photographer \textsc{Nicole Barth}, taken from \url{www.flickr.com/photos/46311827@N07/14885545396}.}
% \label{fig:CowLickingNose}
% \end{figure}

% In \figurename~\ref{fig:CowLickingNose}\myMarginnote{Reference to a figure} you see a cow that is licking its nose. The picture was taken by Nicole Barth on 11.08.2014 using a Canon EOS 500D. The original file has a resolution of $4247 \times 2831$ pixels.
% Note that the image is also referenced.

\chapter{Background}

In this section, a series of data structures, techniques and other relevant aspects are presented in order to lay the foundation for the implementation that is presented in this report. The following subsections aim at providing some background and to frame the state of the art up to the point where the  \cite{patrascu2014dynamic} paper was presented.

The \cite{patrascu2014dynamic} paper presents a dynamic data structure for storing integers and claims that its running times are optimal. We start by looking at what has been done in that research area.

\section{Basic Concepts}

\subsection{Word}
A word consists of a $w$-bit integer. This means that we are bound to an universe $\mathcal U = \{0, 1, ..., 2^{w}-1\}$. The bits that make up a word are indexed from the least (left) to the most (right) significant bit, having the least significant bit index $0$ whereas the most significant has index $w-1$.

\subsection{Universe}
The universe of all possible keys, denoted by $\mathcal U$, has size $u = 2^{w}$. 

\subsection{The Predecessor Problem}\label{sec:predecessorProblem}
Data structures that maintain a set, $S$ of (integer) keys and enable the following operations are said to solve the static predecessor problem \cite{beame1999optimal}:
\begin{itemize}
    \item
    $member(x)$ returns $[x \in S]$.
    \item
    $predecessor(x)$ returns $max\{y\in S\ |\ y < x\}$.
    \item
    $successor(x)$ returns $min\{y\in S\ |\ y \geq x\}$.
\end{itemize}

The predecessor problem can also be dynamic \cite{beame1999optimal} if the said data structure allows:
\begin{itemize}
    \item
    $insert(x)$ sets $S=S \cup \{x\}$.
    \item
    $delete(x)$ sets $S=S \setminus \{x\}$.
\end{itemize}

In this context, the following operations might also be relevant:
\begin{itemize}
    \item
    $rank(x)$ returns $\#\{ y \in S\ |\ y < x\}$.
    \item
    $select(i)$ returns $y \in S$ with $rank(y) = i$, if any.
\end{itemize}

In particular, the data structure presented in \cite{patrascu2014dynamic} not only implements all of the above, and claims that the running times are optimal for all of them are optimal, it also establishes that, by having the operations defined in this manner \cite{patrascu2014dynamic}:
\begin{itemize}
    \item
    $predecessor(x) = select(rank(x - 1))$
    \item
    $successor(x) = select(rank(x))$
\end{itemize}

Given this set of standard operations, this data structure solves the dynamic predecessor problem.

\subsection{Models of Computation}\label{sec:modelsofcomputation}

In order to analyze and describe running times, authors resort to models of computation. Each model states which operations have an associated cost, and which ones do not.
These models provide no unit of cost, and the given operations either have one unit of cost, or none.

Despite their theoretical relevance, when having a data structure and its operations measured against wall clock, one might be surprised with the results.
This is because theoretical bounds have the potential to hide big constants, which are brought to light when wall clock measurements are performed.
Nevertheless, we will enumerate some models of computation, as many of the data structures here presented have their running times described in terms of a given model and therefore it is of interest to provide this context.

The models are presented in descending order from strongest to the least strong. This means that a less restrictive model, such as the cell-probe model is more suited to describe the theoretical \emph{lower} bounds of a data structure than the least stronger ones \cite{erikdemainelec11}.

\subsubsection{The Cell-Probe Model}
In the cell-probe model memory is divided into cells of size $w$, a parameter of the model. Every computation is free.
The only operations that come with an associated cost are reading or writing to memory, which are basically the memory accesses.
Due to its simplicity, as stated in \ref{sec:modelsofcomputation}, it is widely used to prove lower bounds \cite{erikdemainelec11}.

\subsubsection{Trans-dichotomous RAM}
In the trans-dichotomous RAM model, memory consists of an array of size $S$ of $w$-bit words.
Reading or writing to one of the memory cells costs $O(1)$.
Additionally, memory cells can be used as pointers to other cells, e.g. a single $w$-bit word can be used to access another cell.
This implies that, the word length $w$ has to be large enough in order be able to index all to access all cells in the memory.
Let the problem size be $n$:
\begin{equation}\label{eq:problemSize}
    w \ge \log_2(S) \implies w \ge \log_2(n)
\end{equation}
The name is due to expression~\ref{eq:problemSize}, which relates two dichotomies: problem size $n$; and the model of computation with words of size $w$ \cite{erikdemainelec11}. 

\subsubsection{Word RAM}
Similarly to the trans-dichotomous RAM model, the word RAM also operates with fixed size $w$-bit words. Additionally, the following operations have an associated cost \cite{nelsonjelanilec1}:
\begin{itemize}
    \item Integer arithmetic (addition $+$, subtraction $-$, multiplication $\times$, division $\div$ and remainder of division (modulo) $\bmod$);
    \item Bitwise operations (negation $\neg$, and $\wedge$, or $\vee$, exclusive or $\oplus$);
    \item Bitshift operations (right bitshift $\gg$, left bitshift $\ll$).
\end{itemize}

\section{Integer Sets}

Table~\ref{tab:dataStructComparison} can be seen as a summary of relevant data structures that, in incremental steps, led to the data structure presented in this project.

\begin{table}[H]
\centering
\input{src/tex/04_Tables/001_DataStructuresComparison.tex}
\caption[Data structure comparison]{Data structures used to solve the predecessor problem and their respective theoretical running times.}
\label{tab:dataStructComparison}
\end{table}

\subsection{Binary Search Tries}

\subsection{Patricia Tries}

\subsection{Fusion Trees}

\section{Summary of techniques used in the present implementation}

\subsection{Bit operations} \label{sec:bit}

Let $A$ be a $w$-bit length word. In this section we define a small set of functions that operate on $A$'s bits. All the algorithms presented in this section take $O(1)$ time.

\subsubsection{Is the bit set}

This operation is aimed at extracting the bit at position $d$ in $A$. e.g. getting the value of the bit at position $d$. Let us denote such operation by bit$(d, A)$, then bit$(d, A) = (A \gg d) \wedge 1$.
Example:
\begin{align*}
    w = 16\\
    d = 8\\
    A = 0101\ 110\underline{1}\ 1100\ 0111_2& \\
    \text{bit}(8,A) = (0101\ 110\underline{1}\ 1100\ 0111_2& \gg 8) \wedge 1 \\
    \text{bit}(8,A) = (0000\ 0000\ 0101\ 110\underline{1}_2&) \wedge 1 \\
    \cline{1-2}
    \text{bit}(8,A) = 1 &
\end{align*}

\subsubsection{Set bit}
This operation setting the bit at position $d$ in $A$ to one. Let us denote such operation by setBit$(d, A)$, then setBit$(d, A) = A \vee (1 \ll d)$.
Example:
\begin{align*}
    w = 16\\
    d = 4\\
    A = 0101\ 1101\ 110\underline{0}\ 0111_2& \\
    \text{setBit}(4,A) = 0101\ 1101\ 110\underline{0}\ 0111_2& \vee (1 \ll 4) \\
    \text{setBit}(4,A) = 0101\ 1101\ 110\underline{0}\ 0111_2& \vee 0000\ 0000\ 000\underline{1}\ 0000_2 \\
    \cline{1-2}
    \text{setBit}(4,A) = 0101\ 1101\ 110\underline{1}\ 0111_2&
\end{align*}

\subsubsection{Delete bit}
This operation setting the bit at position $d$ in $A$ to zero. Let us denote such operation by deleteBit$(d, A)$, then deleteBit$(d, A) = A \wedge \neg(1 \ll d)$.
Example:
\begin{align*}
    w = 16\\
    d = 6\\
    A = 0101\ 1101\ 1\underline{1}00\ 0111_2& \\
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{1}00\ 0111_2& \wedge \neg(1 \ll 6) \\
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{1}00\ 0111_2& \wedge \neg(0000\ 0000\ 0\underline{1}00\ 0000_2) \\
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{1}00\ 0111_2& \wedge 1111\ 1111\ 1\underline{0}11\ 1111_2 \\
    \cline{1-2}
    \text{deleteBit}(6,A) = 0101\ 1101\ 1\underline{0}00\ 0111_2&
\end{align*}

\subsection{Fields of words}

We follow the definitions from \cite{patrascu2014dynamic} regarding viewing words as sets of fields of some length $f \leq w$. Let $A$ be a $w$-bit length word, then if $A$ is made up of fields, analogously to bit indexing of a word, its least significant field is the right most one, denoted $A\langle0\rangle_f$; its most significant field is the left most one, denoted $A\langle f-1\rangle_f$, and so on. All the algorithms described in this section take $O(1)$ time.

\subsubsection{Field retrieval} \label{sec:fieldRetrieval}

This operation consists of retrieving field $A\langle i\rangle_f$ and it is denoted by getField$(i, f, A)$. It is defined by getField$(i, f, A) = (A \gg (i \times f)) \wedge ((1 \ll f) - 1)$. Example:
\begin{align*}
    i = 1\\
    f = 4\\
    A = 0101\ 1101\ \underline{1100}\ 0111_2& \\
    \text{getField}(1, 4, A) = (0101\ 1101\ \underline{1100}\ 0111_2& \gg (\underbrace{1 \times 4}_{4})) \wedge (\underbrace{(1 \ll 4) - 1}_{1111_2})\\
    \text{getField}(1, 4, A) = 0000\ 0101\ 1101\ \underline{1100}_2& \wedge 0000\ 0000\ 0000\ 1111_2 \\
    \cline{1-2}
    \text{getField}(1, 4, A) = 0000\ 0000\ 0000\ \underline{1100}_2&
\end{align*}

A range of fields can be retrieved in a single operation. We denote by getFields$(i, j, f, A)$ the operation consisting of retrieving the fields $\{A\langle i\rangle_f,\dots , A\langle j-1\rangle_f\}$, which is defined by getFields$(i, j, f, A) = (A \gg (i \times f)) \wedge ((1 \ll ((j - i) \times f)) - 1)$. Example:
\begin{align*}
    i = 1\\
    j = 3\\
    f = 4\\
    A = 0101\ \underline{1101}\ \underline{1100}\ 0111_2& \\
    \text{getFields}(1, 2, 4, A) = (0101\ \underline{1101}\ \underline{1100}\ 0111_2& \gg (\underbrace{1 \times 4}_{4})) \wedge (\underbrace{(1 \ll ((3 - 1) \times 4)) - 1}_{1111\ 1111_2})\\
    \text{getFields}(1, 2, 4, A) = 0101\ \underline{1101}\ \underline{1100}\ 0111_2& \wedge 0000\ 0000\ 1111\ 1111_2 \\
    \cline{1-2}
    \text{getFields}(1, 2, 4, A) = 0000\ 0000\ \underline{1101}\ \underline{1100}_2&
\end{align*}

We can also specify a lower field and retrieve all the fields from that position up to the end of the word. This operation is denoted by getFields$(i, f, A)$ and it is defined by getFields$(i, f, A) = A \gg (i \times f)$. Example:
\begin{align*}
    i = 2\\
    f = 4\\
    A = \underline{0101}\ \underline{1101}\ 1100\ 0111_2& \\
    \text{getFields}(2, 4, A) = \underline{0101}\ \underline{1101}\ 1100\ 0111_2& \gg (\underbrace{2 \times 4}_{8})\\
    \cline{1-2}
    \text{getFields}(1, 2, 4, A) = 0000\ 0000\ \underline{0101}\ \underline{1101}_2&
\end{align*}

\subsubsection{Field assignment}

Conversely, it is also possible to assign a value to a particular field. To so, we need an auxiliary variable $m$, computed as a function of $i$ (the position of the field to be set) and $f$ (the length of the fields in $A$). Thus we have $m = ((1 \ll f) - 1) \ll (i \times f)$. Setting field $y$ in $A$, denoted by setField$(i, y, f, A)$ is defined by:
\begin{equation*}
    \text{setField}(i, y, f, A) = \underbrace{(A \wedge \neg m)}_{\text{(a) Reset field}} \vee \ \underbrace{(y \ll (i \times f) \wedge m)}_{\text{(b) Set field}}
\end{equation*}
Example:
\begin{align*}
    i = 1\\
    y = 1001_2\\
    f = 4\\
    m = (\underbrace{(1 \ll 4)  - 1} _{1111_2}) \ll (\underbrace{1 \times 4}_{4}) = 0000\ 0000\ 1111\ 0000_2\\
    A = 0101\ 1101\ \underline{1100}\ 0111_2& \\
    \cline{1-2}
    \text{(a)}\quad A \wedge \neg m = 0101\ 1101\ \underline{1100}\ 0111_2 & \wedge 1111\ 1111\ 0000\ 1111_2\\
    \text{(b)}\quad y \ll (1 \times 4) \wedge m = 1001_2 \ll 4 & \wedge 0000\ 0000\ 1111\ 0000_2\\
    \text{setField}(1, y, 4, A) = \text{(a)} \vee \text{(b)} = 0101\ 1101\ \underline{0000}\ 0111_2& \vee 0000\ 0000\ \underline{1001}\ 0000_2 \\
    \cline{1-2}
    \text{setField}(1, y, 4, A) = 0101\ 1101\ \underline{1001}\ 0111_2&
\end{align*}

\subsection{Most significant set bit}

Learning about the most significant set bit of a word will be an important operation in the implementation. For this reason, we have looked at different ways to achieve this result efficiently. Since it is to be used as a subroutine in certain operations, it has the potential to become a bottleneck if not implemented carefully. Let the most significant set bit of $x$ be denoted msb$(x)$.

\subsubsection{Naive}

The simplest way to achieve the intended outcome is to loop through the word until the first non-zero bit is found, returning the number of iterations that it took to find that bit.

This approach takes $O(w)$ time.

\subsubsection{Lookup}

In this approach, a lookup table containing the most significant bits answers for all combinations of 8 bits is pre-computed.

When a query comes, it is iterated in fields of 8-bit, starting from the most significant field. If those bits are not zero, then the most significant bit of the queried word lies in that block. In such case, the answer will be the most significant set bit of that field plus all the in the non-iterated fields. Since the answer to any combination of of 8 bits is pre-computed, then we know the answer in constant time.

Otherwise, if the first field 0, the algorithm looks at the second most significant field and does the same operation as described in the previous paragraph.

This approach takes $O(1)$ time after the lookup table has been computed but, not only the lookup table takes time to compute, it also uses some space.

\subsubsection{Constant time with parallel comparison}

This operation consists of 4 steps. Let $x$ be the query for the most significant set bit:
\begin{enumerate}
    \item
    We divide $x$ in $\sqrt{w}$ fields of $\sqrt{w}$ bits. The goal is to summarize the fields in $x$ such that if a field is not empty, then its summary is $1$ and $0$  (zero) otherwise.
    \item
    We compress the summary such that it fits in a single $\sqrt{w}$-bits field. The resulting field will have all the leading bits of the summary word consecutive.
    \item
    Then we do parallel comparison of the summary word to find the first non-empty field of $x$, because it will be on that field that the answer will lie.
    \item
    We use the same technique as in the previous bullet point, but now on the first non-empty field of $x$. We end with simple arithmetic to return the most significant set bit. 
\end{enumerate}

We will run a small example where every step will be illustrated. For simplicity, let $w=16$. This implies that we will have $\sqrt{16} = 4$ fields of $4$ bits in size each. Let us also assume that our query $x = 0101\ 0000\ 1000\ 1101_2$.

This approach takes $O(1)$ time and requires a small lookup table of $\sqrt{w}/2$ size, which can easily be explicitly stored together with the algorithm.

\paragraph{Step 1 --- Summarize the query fields} \label{sec:summaryfields}

The goal of this step is to compute a summary word whose leading bit of each of its fields is a summary of each field of the query word $x$. If in a given field $f_i$ the leading bit in the summary word is $1$, then $f_i$ in $x$ was not empty (one or more bits were set), and vice-versa.

\begin{enumerate}
    \item \label{blt:msb1}
    We start by finding $F$. $F$ is a $w$-bit word where the most significant position of every field is set to $1$ and every other position is set to $0$. In this particular example $F = 1000\ 1000\ 1000\ 1000_2$
    
    \item \label{blt:msb2}
    In a local variable $t_1$, we store information about the leading bits of each field of $x$. This is done with $x \wedge F$.
    \begin{align*}
                       x &= \underline{0}101\ \underline{0}000\ \underline{1}000\ \underline{1}101_2 \\
                       F &= 1000\ 1000\ 1000\ 1000_2 \\ \cline{1-2} 
        t_1 = x \wedge F &= \underline{0}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2
    \end{align*}
    
    \item \label{blt:msb3}
    In another local variable $t_2$, we store $x$ after setting the leading bits of each field to zero. This is done with $x \oplus t_1$.
    \begin{align*}
                         x &= 0\underline{101}\ 0\underline{000}\ 1\underline{000}\ 1\underline{101}_2 \\
                       t_1 &= 0000\ 0000\ 1000\ 1000_2 \\ \cline{1-2}
        t_2 = x \oplus t_1 &= 0\underline{101}\ 0\underline{000}\ 0\underline{000}\ 0\underline{101}_2
    \end{align*}
    
    \item \label{blt:msb4}
    We subtract $t_2$ from $F$ and save it to a local variable $t_3$. Since the leading bit of every field of $F$ is one, after subtracting $t_2$ to $F$ what remains is the information about if that field was empty (all zeros) or not. This information is given by the bit that remains at the most significant position of each resulting field. For any given field, if the most significant bit is one, then it means that the corresponding field in $x$ was empty. Otherwise, it was not empty. Since we only care about what remains of in the most significant position of each field, in the example below the remaining noise has been replaced with $?$.
    \begin{align*}
                    F &= 1000\ 1000\ 1000\ 1000_2 \\
                  t_2 &= 0\underline{101}\ 0\underline{000}\ 0\underline{000}\ 0\underline{101}_2 \\ \cline{1-2} 
        t_3 = F - t_2 &= \underline{0}???\ \underline{1}000\ \underline{1}000\ \underline{0}???_2
    \end{align*}
    
    \item \label{blt:msb5}
    This step consists of clearing the noise from $t_3$ since we care only about knowing if which fields in $x$ were empty or not. To do so, $(\neg t_3) \wedge F$.
    \begin{align*}
                       t_3 &= \underline{0}???\ \underline{1}000\ \underline{1}000\ \underline{0}???_2 \\ \cline{1-2} 
            t_4 = \neg t_3 &= \underline{1}???\ \underline{0}111\ \underline{0}111\ \underline{1}???_2 \\
                         F &= 1000\ 1000\ 1000\ 1000_2 \\ \cline{1-2} 
        t_5 = t_4 \wedge F &= \underline{1}000\ \underline{0}000\ \underline{0}000\ \underline{1}000_2
    \end{align*}
    
    \item \label{blt:msb6}
    The value calculated in \ref{blt:msb2} for $t_1$ holds information about the leading bits of each field, whereas $t_5$ from \ref{blt:msb5} contains the information about the non-leading bits. By merging both words, the resulting word will hold information about the whole word $x$. We achieve this with $t_1 \vee t_5$.
    \begin{align*}
                       t_1 &= \underline{0}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2 \\
                       t_5 &= \underline{1}000\ \underline{0}000\ \underline{0}000\ \underline{1}000_2 \\ \cline{1-2} 
        t_6 = t_1 \vee t_5 &= \underline{1}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2
    \end{align*}
\end{enumerate}

In fact, once $F$ is known, steps \ref{blt:msb2} to \ref{blt:msb5} can be computed all at once with the expression:
\begin{equation}
    t_6 = (x \wedge F) \vee ((\neg(F - (x \oplus(x \wedge F)))) \wedge F)
\end{equation}

\paragraph{Step 2 --- Summary compression} \label{sec:summaryCompression}
% minuto 1.12: https://www.youtube.com/watch?v=xSGorVW8j6Q&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf&index=12

The goal of this step is to compress the summary word down to a single field.

\begin{enumerate}
    \item \label{blt:summCompression1}
    The first step consists of shifting the leading bits of each field to the least significant position of each field. This is done with $t_6 \gg (\sqrt{w} - 1)$. 
    \begin{align*}
                    t_6 &= \underline{1}000\ \underline{0}000\ \underline{1}000\ \underline{1}000_2 \\ \cline{1-2} 
        t_7 = t_6 \gg 3 &= 000\underline{1}\ 000\underline{0}\ 000\underline{1}\ 000\underline{1}_2
    \end{align*}
    
    \item \label{blt:summCompression2}
    We wish now to copy the least significant bit of each field to a single field, keeping their relative order.
    Similarly to \ref{sec:summaryfields}.\ref{blt:msb1}, we need to find a word $C$ which when multiplied by $t_6$ will produce the result we are looking for.
    Let $C$ be also partitioned in fields indexed $\{f_0, ..., f_{\sqrt{w} - 1}\}$ where $f_{\sqrt{w} - 1}$ is the most significant field. At every field $f_i$, the only set bit is $b_{\sqrt{w} - 1 - i}$).
    In our example $C = 0001\ 0010\ 0100\ 1000_2$.
    
    \item \label{blt:summCompression3}
    Multiplying $C$ with $t_7$ produces a result $t_8$ with all the important bits in their relative order in the most significant field. There will be some additional noise in the least significant fields, which we can easily clear by $t_8 \gg ((\sqrt{w})\cdot(\sqrt{w} - 1))$.
        \begin{align*}
                         t_7 &= 000\underline{1}\ 000\underline{0}\ 000\underline{1}\ 000\underline{1}_2 \\
                           C &= 0001\ 0010\ 0100\ 1000_2 \\ \cline{1-2} 
          t_8 = t_7 \times C &= \underline{1011}\ ????\ ????\ ????_2\\ \cline{1-2}
        t_9 = t_8 \gg (16-4) &= 0000\ 0000\ 0000\ \underline{1011}_2
    \end{align*}
\end{enumerate}

\paragraph{Step 3 --- First non-empty field with parallel comparison} \label{sec:parallel}
At this stage the goal is to know the first non-empty field of $x$. To do so, we need to do a parallel comparison between $t_9$ (the summary of $x$'s fields) and all the $\sqrt{w}$ powers of two. Parallel comparison requires 1 extra bit per comparable block: this is because, similarly to the step taken in \ref{sec:summaryfields}.\ref{blt:msb4}, a subtraction is done in order to figure out at which position the leading $1$ is borrowed. Since in total we need $\sqrt{w}\cdot(\sqrt{w} + 1)$ bits to for the vectors, and $\sqrt{w}\cdot(\sqrt{w} + 1) > w$, we know that it might be necessary to do this operation in two iterations: one for the higher powers of two, and another for the lower ones. We know also that, the result of operation is a monotone function, meaning that once the transition on the leading bit is found, the result is found. This also implies that if the result if found in the higher powers of two, then it is not necessary to look for it in the lower end.

\begin{enumerate}
    \item \label{blt:parallel1}
    We define two vectors, $hi$ and $lo$, with $hi > lo$, which are comprised of the concatenation of the $\sqrt{w}$ powers of two in sorted in descending order and padded with $1$. To each power of two, have to subtract $1$ for this operation to work, because if we do not and the query is an exact power of two, the corresponding padding $1$ will not be borrowed. In our example:
    \begin{align*}
        hi &= 1\ \underbrace{0111}_{2^3-1=7}\ 1\ \underbrace{0011}_{2^2-1=3}{}_2\\
        lo &= 1\ \underbrace{0001}_{2^1-1=1}\ 1\ \underbrace{0000}_{2^0-1=0}{}_2
    \end{align*}
    
    \item \label{blt:parallel2}
    We define another vector $t_{10}$ consisting of $\sqrt{w}/2$ concatenated copies of $t_9$ where each of the copies is prefixed by zero. This vector is achieved by multiplying $t_9$ with a word $M$ consisting of $\sqrt{w}/2$ fields of size $\sqrt{w} + 1$ where the least significant bit of each field is set to $1$. Note that, because we have set the size of each field of $M$ to have an additional bit, this corresponds to prefix a zero to each $\sqrt{w}$ field:
    \begin{align*}
        t_9 = 0000\ 0000\ 0000\ &\underline{1011}_2\\ 
        M = 0\ 0001\ 0\ &0001_2\\ \cline{1-2}
        t_{10} = t_9 \times M = 0\ \underline{1011}\ 0\ &\underline{1011}_2
    \end{align*}
    
    \item \label{blt:parallel3}
    To find the first non-empty field of $x$, we take the differences between $t_{10}$ and $hi$ and $lo$ respectively. The answer will lie one the first field which leading bit resulted in a zero after the operation.
    \begin{align*}
                          hi &= \underline{1}\ \underline{1}000\ \underline{1}\ \underline{01}00_2\\
                          lo &= \underline{1}\ \underline{001}0\ \underline{1}\ \underline{0001}_2 \\
                      t_{10} &= 0\ 1011\ 0\ 1011_2\\ \cline{1-2}
        t_{11} = hi - t_{10} &= \underline{0}\ ????\ \underline{0}\ ????_2 \\
        t_{12} = lo - t_{10} &= \underline{0}\ ????\ \underline{0}\ ????_2
    \end{align*}
    
    \item \label{blt:parallel4}
    Looking at $t_{11}$, we note that the first non-empty field of $x$ is the first, because the leading bit of first field resulting from difference between $hi$ and $t_{10}$ is now zero. Nevertheless,  we will do the same operations on both $t_{11}$ and $t_{12}$ and concatenate the results so we end up with a single result for the whole query. Note that in the previous step the actual values within each field besides the leading bit are irrelevant, so we do some masking and shifting, similar to what was done in \ref{sec:summaryfields} and \ref{sec:summaryCompression}.
    \begin{enumerate}
        \item
        The first step is to clear all the irrelevant bits in the fields and turn the leading bits from zero to one. We choose a mask for this specific purpose.
        \begin{align*}
            t_{11} = \underline{0}\ ????\ \underline{0}\ ????_2&\\
            t_{12} = \underline{0}\ ????\ \underline{0}\ ????_2&\\
            Mask_1 = 1\ 0000\ 1\ 0000_2&\\ \cline{1-2}
            t_{13} = (t_{11} \wedge Mask_1) \oplus Mask_1 = \underline{1}\ 0000\ \underline{1}\ 0000_2&\\
            t_{14} = (t_{12} \wedge Mask_1) \oplus Mask_1 = \underline{1}\ 0000\ \underline{1}\ 0000_2&
        \end{align*}
        \item
        Secondly, we wish to summarize the results in a single field. To achieve so, we first multiply the vectors by an integer $V$, which construction follows what we have done for \ref{sec:summaryCompression}.\ref{blt:summCompression2}, and that result will put all the important bits consecutive in the most significant field.
        
        \begin{align*}
            t_{15} = t_{13} \gg \sqrt{w} = 0\ 000\underline{1}\ 0\ 000\underline{1}_2& \\
            t_{16} = t_{14} \gg \sqrt{w} = 0\ 000\underline{1}\ 0\ 000\underline{1}_2& \\
            \cline{1-2}
            V =\ 01000\ 10000_2 & \\
            t_{17} = t_{15} \times V =\ ???????\ \underline{11}00?\ ?????_2& \\
            t_{18} = t_{16} \times V =\ ???????\ \underline{11}00?\ ?????_2& \\
        \end{align*}
        \item
        After the multiplication, we have to remove the noise and move the result to the least significant field. We achieve this by defining another mask for this purpose, followed by the necessary bit shifts. The final step will be to merge the results of the higher and the lower powers of two: $t_{hi} \vee t_{lo}$.
        
        \begin{align*}
            Mask_2 = 11_2&\\
            t_{19} = t_{17} \wedge (Mask_2 \ll 2\cdot \sqrt{w}) =\ \underline{11}\ 0000\ 0000_2& \\
            t_{20} = t_{18} \wedge (Mask_2 \ll 2\cdot \sqrt{w}) =\ \underline{11}\ 0000\ 0000_2& \\
            \cline{1-2}
            t_{hi} = t_{19} \gg (\sqrt{w} + \sqrt{w}/2) = 00\ 0000\ \underline{11}00_2 &\\
            t_{lo} = t_{20} \gg (\sqrt{w} \cdot \sqrt{w} / 2) = 00\ 0000\ 00 \underline{11}_2 &\\
            \cline{1-2}
            t_{q} = t_{hi} \vee t_{lo} = \underline{1111}_2 &\\
        \end{align*}
    \end{enumerate}
    \item
    Note that $t_q$ can only be one of $\sqrt{w}$ possibilities: $0001_2$, $0011_2$, $0111_2$, or $1111_2$. For this reason, we implement a lookup table of size $\sqrt{w}$ for these values, which we return at the end of the method. We can even halve the size of the lookup table by applying the following trick: instead of merging $t_{hi}$ and $t_{lo}$ in to a single field, shift $t_{hi}$ all the way to the right. In this scenario, $t_{hi}$ can either be $11_2$, $01_2$ or $0$. The values of the lookup table in this case will be only $11_2$ and $01_2$, so if $t_{hi}$ takes one of those values, we return the value in the lookup table plus a constant corresponding to the least significant positions ($\sqrt{w}/2$). Should it be $0$, then we do the lookup for $t_{lo}$ and return the corresponding value in the lookup table.
    
    In our example, since $t_{q} = 1111_2$ the result of this parallel comparison would be $3$ (three), meaning, the method should now look at field $c_3$ (the most significant field).
\end{enumerate}

\paragraph{Step 4 --- Final result}
After learning in which field lies the most significant bit, we now run the same method as in \ref{sec:parallel} but now with the actual field.

\begin{enumerate}
    \item
    We start by extracting the field from our query $x$. Let $i$ be the result returned from \ref{sec:parallel}, e.g. the index of the field. We extract $f_i$ by shifting $(\sqrt{w} - 1 - i)$ fields in $x$ to the right and ANDing the result with a mask for this purpose.
    \begin{align*}
        x = \underline{0101}\ 0000\ 1000\ 1101_2 &\\
        Mask_3 = 0000\ 0000\ 0000\ 1111_2 &\\
        \cline{1-2}
        t_{21} = (x \gg \underbrace{(\sqrt{w} \cdot (\sqrt{w} - 1 - i))}_{4\times(4-1-0)}\ \wedge\ Mask_3 = 0000\ 0000\ 0000\ \underline{0101}_2 &
    \end{align*}
    \item
    We run another parallel comparison with $0101_2$. Let $d$ be the result of computing the parallel comparison of the first non-empty field of $x$, then in our example $d = 2$.
    \item
    We can now compute the overall most significant bit of $x$. The final result is given the expression:
    \begin{equation*}
        \text{msb}(x) = d + i\cdot\sqrt{w}
    \end{equation*}
    In our example, this will evaluate to:
    \begin{equation*}
        \text{msb}(0101\ 0000\ 1000\ 1101_2) = 2 + 3\cdot\sqrt{16} = 2 + 3 \times 4 = 14
    \end{equation*}
\end{enumerate}

\subsection{Least significant set bit}

Let lsb$(x)$ denote the least significant set bit of $x$. Citing Pătrașcu and Thorup, after computing the msb$(x)$ we can in $O(1)$ time compute lsb$(x)$ with the expression:
\begin{equation*}
    \text{lsb}(x) = \text{msb}((x - 1) \oplus x)
\end{equation*}

Example:
\begin{align*}
    x = 0101\ 1101\ 1100\ 0\underline{1}00_2& \\
    x - 1 = 0101\ 1101\ 1100\ 0\underline{0}11_2& \\
    (x - 1) \oplus x = 0000\ 0000\ 0000\ 0\underline{1}00_2& \\
    \cline{1-2}
    \text{lsb}(x) = \text{msb}((x - 1) \oplus x) = \text{msb}(0000\ 0000\ 0000\ 0\underline{1}00_2&) = 2
\end{align*}

\subsection{Rank Lemma 1}

Another important operation for the purpose of the implementing the data structure presented in \cite{patrascu2014dynamic} is to compute the rank of a word. To achieve the latter, subroutines are established and the algorithm described in this section is one of them. This algorithm consists of the implementation of Lemma~\ref{lemma1} by Fredman and Willard, cited by Pătrașcu and Thorup. It reads:
\begin{lemma} \label{lemma1}
Let $m \cdot b \leq w$. If we are given a b-bit number x and a word A with m b-bit numbers stored in sorted order, that is, $A\langle 0 \rangle_b < A\langle 1 \rangle_b < \dots < A\langle m - 1 \rangle_b$, then in constant time, we can find the rank of x in A, denoted rank(x,A).
\end{lemma}
An algorithm that implements rank$(x,A)$ works as the following:
\begin{enumerate}
    \item
    Computing how many fields in $A$ have zero as their leading bit.
    
    \item
    Computing the leading bit of $x$.
    
    \item
    If the leading bit of $x$ is zero, then:
    \begin{enumerate}
        \item
        We bit-shift and/or mask $A$ such that the fields whose leading bit is one are no longer present in $A$.
        
        \item
        We compute a word consisting of as many concatenated copies of $x$ as there are fields left in $A$.
        
        \item
        We do parallel comparison between (the shifted/masked) $A$ and (copies of) $x$ by setting the leading bit of each of the remaining fields of $A$ to one and computing the difference between those words.
        
        \item
        The result of rank$(x,A)$ is given by the number of fields whose leading bit is now zero because if the leading bit (that has been set to one in the previous step) is borrowed in the subtraction, then $x$ is larger than the key stored at that field.
    \end{enumerate}
    
    Otherwise, if the leading bit of $x$ is one, then:
    \begin{enumerate}
        \item
        We bit-shift and/or mask $A$ such that the fields whose leading bit is zero are no longer present in $A$, storing the number of fields removed from $A$ on a local variable.
        
        \item
		We set the leading bit of $x$ to zero and compute a word consisting of as many concatenated copies of $x$ as there are fields left in $A$.
		
		\item
        We do parallel comparison between the remaining fields in $A$ and the word we computed just before.
        
        \item
        The result of rank$(x,A)$ is given by the number of fields whose leading bit was zero just before $A$ was shifted/masked plus the number of fields whose leading bit is zero after the parallel comparison.
    \end{enumerate}
    
\end{enumerate}

This operation takes $O(1)$ time and we will run an example of this algorithm, explaining its intricacies.

\subsubsection{Parameters}

Since this algorithm branches depending on the leading bit of the query, we will run the example with two queries $x_1$ and $x_2$ such that we explore both branches of the algorithm. Let $A$ be the concatenation of the keys of $S = \{0101_2, 0110_2, 1100_2, 1110_2 \}$. Note that if key $y_i < y_j$, then $y_i$ will be present in $A$ on a lesser significant position than $y_j$.
\begin{align*}
    A &= \underbrace{1110}_{A\langle 3 \rangle_4}\ \underbrace{1100}_{A\langle 2 \rangle_4}\ \underbrace{0110}_{A\langle 1\rangle_4}\ \underbrace{0101}_{A\langle 0 \rangle_4}{}_2 \\
    x_1 &= 1100_2 \\
    x_2 &= 0111_2 \\
    b &= 4 \\
    m &= 4
\end{align*}

\subsubsection{Step 1 --- Computing which fields have zero as their leading bit} \label{sec:computeM}

Since the keys in $A$ are sorted, we know that finding the position the least significant field whose first bit is one in $A$ will be tell us how many fields there are with zero at their leading bit.

\begin{enumerate}
    \item
    We start by finding $M$. $M$ consists of a word with $m$ fields of $b$-bits, where each field is filled with zeroes excluding the least significant bit, which is set to one. In this particular example $M = 0001\ 0001\ 0001\ 0001_2$.
    
    \item % A & (M << (b - 1))
    We mask the non-leading bits of each field of $A$. This is achieved with $A \wedge (M \ll (b - 1))$.
    
    \begin{align*}
        M &= 0001\ 0001\ 0001\ 0001_2 \\
        t_1 = M \ll (b - 1) &= 1000\ 1000\ 1000\ 1000_2 \\
        A &= \underline{1}110\ \underline{1}100\ \underline{0}110\ \underline{0}101_2 \\
        \cline{1-2}
        t_2 = A \wedge t_1 &= \underline{1}000\ \underline{1}000\ \underline{0}000\ \underline{0}000_2
    \end{align*}
    
    \item
    Computing lsb$(t_2)$ will give us the index of leading bit of the least significant field whose leading bit is one. Dividing the previous result by the field size $b$ will then give us the  field position results in total number of fields in $A$ whose leading bit is zero. In this particular example:
    \begin{align*}
        &\text{lsb}(t_2) = \text{lsb}(1000\ \underline{1}000\ 0000\ 0000_2) = 11 \\
        &t_3 = \frac{\text{lsb}(t_2)}{b} = \frac{11}{4} = 2 \\
    \end{align*}
\end{enumerate}

\subsubsection{Step 2 --- Computing the leading bit of the query}
In order to extract the value of the leading bit of our queries $x_1$ and $x_2$, we resort to the algorithm of section~\ref{sec:bit}. The leading bit of the query will be at position $b - 1$, thus we have for $x_1$:
\begin{align*}
    x_1 = \underline{1}100&_2\\
    \text{bit}(b - 1, x_1) = \text{bit}(3, x_1) = 1\\
\end{align*}
And for $x_2$:
\begin{align*}
    x_2 = \underline{0}111&_2\\
    \text{bit}(b - 1, x_2) = \text{bit}(3, x_2) = 0\\
\end{align*}

\subsubsection{Step 3 --- Computing rank with parallel comparison}

We will now run the algorithm for each of its branches. If the leading bit of the query if one, then we run the first branch; otherwise the second.
\begin{itemize}
    \item
    In this branch our query is $x_1 = 1100_2$:
    \begin{enumerate}
        \item
        Since the leading bit of our query $x_1$ is one, we know now that its rank in $A$ is at least the number of fields in $A$ whose leading bit is zero. So we proceed by removing those fields from $A$, and for this purpose we resort to the getFields$(i, f, A)$ defined in Section~\ref{sec:fieldRetrieval}. In our example:
        \begin{align*}
            A &= \underline{1110}\ \underline{1100}\ 0110\ 0101_2 \\
            t_3 &= 2 \\
            A := \text{getFields}(t_3, b, A) &= 0000\ 0000\ \underline{1110}\ \underline{1100}_2 \\
        \end{align*}
        
        \item
        We apply the same principle to the $M$ word by doing the very same operation as just before.
        \begin{align*}
            M &= \underline{0001}\ \underline{0001}\ 0001\ 0001_2 \\
            t_3 &= 2 \\
            \cline{1-2}
            M := \text{getFields}(t_3, b, M) &= 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
        \end{align*}
        
        \item
        We set the leading bit of $x_1$ to zero and multiply it by $M$ to produce a word containing concatenated copies of $x_1$.
        \begin{align*}
            x_1 = 1100_2 \\
            M = 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
            \cline{1-2}
            x_1 := \text{deleteBit}(b - 1, x_1) = 0100_2 \\
            \cline{1-2}
            x_1 := x_1 \times M = 0000\ 0000\ \underline{0100}\ \underline{0100}_2 \\
        \end{align*}
        
        \item
        The last ingredient needed for the parallel comparison is a mask comprised of a word whose leading bit of each field is one. Shifting $M$ by $b - 1$ positions to the left will produce such result.
        \begin{align*}
            M = 0000\ 0000\ 000\underline{1}\ 000\underline{1}_2& \\
            \cline{1-2}
            M := M \ll (b - 1) = 0000\ 0000\ \underline{1}000\ \underline{1}000_2& \\
        \end{align*}
        
        \item
        We take the difference between $A$ and $x$ and mask out the bits at all positions except the leading bits of each field in the resulting word.
        \begin{align*}
            A &= 0000\ 0000\ 1\underline{110}\ 1\underline{100}_2 \\
            x_1 &= 0000\ 0000\ 0\underline{100}\ 0\underline{100}_2 \\
            M &= 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
            \cline{1-2}
            A - x_1 &= 0000\ 0000\ \underline{1}???\ \underline{1}???_2 \\
            d_1 = (A - x_1) \wedge M &= 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
        \end{align*}
        
        \item
        To learn how many of the remaining of fields in $A$ that are smaller than $x_1$, we compute lsb($d_1$) and divide it by $b$.
        \begin{align*}
            d_1 = 0000\ 0000\ 1000\ \underline{1}000_2 \\
            \text{lsb}(d_1) = 3 \\
            b = 4 \\
            \cline{1-2}
            t_4 = \frac{\text{lsb}(d_1)}{b} = \frac{3}{4} = 0 
        \end{align*}
        
        \item
        Computing rank$(x_1, A)$ consists of returning the number of fields in $A$ that are strictly smaller than $x$. In this specific context, we know that all fields whose leading bit is zero are smaller than $x_1$, and we have also just computed the number of fields whose leading bit is one but that are still smaller than $x_1$. So we just add those results, and we have:
        \begin{align*}
            \text{rank}(x_1, A) &= t_3 + t_4 = 2 + 0 \\
            \text{rank}(x_1, A) &= 2
        \end{align*}
        
    \end{enumerate}
    \item
    In this branch our query is $x_2 = 0111_2$:
    \begin{enumerate}
        \item
        Since the leading bit of our query $x_2$ is zero, we can safely disregard the fields in $A$ whose leading bit is one. Similarly to what was done in the first branch, $M$ suffers a similar change, and we will start with that by using the getFields$(i, j, f, A)$ function defined in Section~\ref{sec:fieldRetrieval}. Thus we have:
        \begin{align*}
            M &= 0001\ 0001\ \underline{0001}\ \underline{0001}_2 \\
            t_3 &= 2 \\
            \cline{1-2}
            M := \text{getFields}(0, t_3, b, M) &= 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
        \end{align*}
        
        \item
        We need to have as many concatenated copies of $x_2$ as there are fields in $A$ whose leading bit is zero. So we multiply $M$ by $x_2$ and we end with:
        \begin{align*}
            x_2 = 0111_2 \\
            M = 0000\ 0000\ \underline{0001}\ \underline{0001}_2 \\
            \cline{1-2}
            x_2 := x_2 \times M = 0000\ 0000\ \underline{0111}\ \underline{0111}_2 \\
        \end{align*}
        
        \item
        As before, we need a mask to perform the parallel comparison. So we use the same technique as in the other branch and shift $M$ by $b-1$ positions to the left:
        \begin{align*}
            M = 0000\ 0000\ 000\underline{1}\ 000\underline{1}_2& \\
            \cline{1-2}
            M := M \ll (b - 1) = 0000\ 0000\ \underline{1}000\ \underline{1}000_2& \\
        \end{align*}
        
        \item
        Lastly, for the last ingredient of the parallel comparison, we discard the fields in $A$ whose leading bit is one, and set the leading bit of remaining fields to one. Thus we have:
        \begin{align*}
            A = &\ 1110\ 1100\ \underline{0110}\ \underline{0101}_2 \\
            t_3 = &\ 2 \\ 
            M = &\ 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
            \cline{1-2}
            A := \text{getFields}(0, t_3, b, A) = &\ 0000\ 0000\ \underline{0110}\ \underline{0101}_2 \\
            \cline{1-2}
            A := M \vee A = 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \vee &\ 0000\ 0000\ \underline{0}110\ \underline{0}101_2 \\
            \cline{1-2}
            A = &\ 0000\ 0000\ \underline{1}110\ \underline{1}101_2
        \end{align*}
        
        \item
        We take the difference between $A$ and $x_2$ and mask out the bits at all positions except the leading bits of each field in the resulting word.
        \begin{align*}
            A &= 0000\ 0000\ 1\underline{110}\ 1\underline{101}_2 \\
            x_2 &= 0000\ 0000\ \underline{0111}\ \underline{0111}_2 \\
            M &= 0000\ 0000\ \underline{1}000\ \underline{1}000_2 \\
            \cline{1-2}
            A - x_2 &= 0000\ 0000\ \underline{0}???\ \underline{0}???_2 \\
            d_2 = (A - x_2) \wedge M &= 0000\ 0000\ \underline{0}000\ \underline{0}000_2 \\
        \end{align*}
        
        \item
        Note that $d_2$ is zero. Since there are no set bits in $d_2$ then $x_2$ is larger than all $x_2$ must be larger than all the remaining fields in $A$, so we just return $t_2$.
        \begin{align*}
            \text{rank}(x_2,A) &= t_3 = 2 \\
        \end{align*}
        
    \end{enumerate}
\end{itemize}




\chapter{Implementation of theoretically optimal dynamic rank, select, and predecessor data structure}

\subsection{Code base navigation}

\section{The {\ttfamily RankSelectPredecessorUpdate} interface}

As stated in Section~\ref{sec:predecessorProblem}, the data structure presented in \cite{patrascu2014dynamic} solves the dynamic predecessor problem. For this reason, an interface denoted {\ttfamily RankSelectPredecessorUpdate} was implemented with the methods:
\begin{itemize}
    \item
    The $insert(x)$ sets $S=S \cup \{x\}$ operation is to be implemented by a method with the signature:
    \begin{lstlisting}
    void insert(long x);
    \end{lstlisting}
    
    \item
    The $delete(x)$ sets $S=S \setminus \{x\}$ operation is to be implemented by a method with the signature:
    \begin{lstlisting}
    void delete(long x);
    \end{lstlisting}
    
    \item
    The $member(x)$ returns $[x \in S]$ operation is to be implemented by a method with the signature:
    \begin{lstlisting}
    boolean member(long x);
    \end{lstlisting}

    \item
    The $predecessor(x)$ returns $max\{y\in S\ |\ y < x\}$ operation is implemented as a default method, making all implementing classes automatically inheriting the method:
    \begin{lstlisting}
    default Long predecessor(long x) {
        return select(rank(x) - 1);
    }
    \end{lstlisting}

    \item
    The $successor(x)$ returns $min\{y\in S\ |\ y \geq x\}$ operation is implemented as a default method, making all implementing classes automatically inheriting the method:
    \begin{lstlisting}
    default Long successor(long x) {
        return select(rank(x));
    }
    \end{lstlisting}

    \item
    The $rank(x)$ returns $\#\{ y \in S\ |\ y < x\}$ operation is to be implemented by a method with the signature:
    \begin{lstlisting}
    long rank(long x);
    \end{lstlisting}

    \item
    The $select(i)$ returns $y \in S$ with $rank(y) = i$ operation is to be implemented by a method with the signature:
    \begin{lstlisting}
    Long select(long rank);
    \end{lstlisting}
\end{itemize}
Additionally, the following methods are included in the interface:
\begin{itemize}
    \item
    A {\ttfamily size()} method that returns the current number of keys in the set:
    \begin{lstlisting}
    long size();
    \end{lstlisting}

    \item
    An {\ttfamily isEmpty()} default method that returns {\ttfamily true} if the set is empty and {\ttfamily false} otherwise:
    \begin{lstlisting}
    default boolean isEmpty() {
        return size() == 0;
    }
    \end{lstlisting}

    \item
    A {\ttfamily reset()} method that removes all current elements from the set:
    \begin{lstlisting}
    void reset();
    \end{lstlisting}
\end{itemize}

Note that some of the methods return a primitive type, whereas some others return a boxed type. This is due to the fact that some queries are not mapped to any answer, and the boxed type provides the perfect way to model this kind of scenario: in such situation {\ttfamily null} is returned.

\section{Naive implementation}
We start with a naive implementation of name {\ttfamily NaiveDynamicFusionNode}. It holds a {\ttfamily key} array to store the keys, and a counter for the current number of keys in the data structure. The keys can be any 64-bit integer.

The basic idea behind this implementation is to store the keys in {\ttfamily key}, making their respective rank the same as the their index in that array. In other words, {\ttfamily key} is always sorted.

Updates, e.g. insert and delete, take $O(n)$ time. This is because whenever a key is inserted, its rank $i$ is found, and the key at that position as well as all following keys up to $n-1$ are updated. Since any given key index in {\ttfamily key} is its rank, all the keys with rank larger than the new key have to be moved one position to the right in {\ttfamily key} to make room for the new key and keeping rank consistent.

A rank query takes $O(\log_2(n))$ because a binary search is performed on {\ttfamily key}. Select is faster: $O(1)$, because we need only to access and return the key at position {\ttfamily i} in {\ttfamily key} to fulfill the query.

\section{{\ttfamily DynamicFusionNode} with binary search for Rank}
We take a step forward by improving on the previous idea: this time, two additional words, {\ttfamily index} and {\ttfamily bKey} are kept in the fields. The goal is to use the concepts described in the \textit{Indexing} chapter of \cite{patrascu2014dynamic} to implement this data structure. The running times will be $O(\log_2 n)$ for updating and querying, and this is because the {\ttfamily rank} operation resorts to binary search to produce the result.

We interpret {\ttfamily bKey} as an array where the values first $k$ bits correspond to the positions in {\ttfamily key}. Let us assume that the bits in {\ttfamily bKey} are indexed from $0$ to $k-1$: if the $i^{th}$ bit is set to $1$, then position $i$ in {\ttfamily key} is free and can store a key, and vice-versa.

We interpret {\ttfamily index} as an array of $k$ entries, each taking $\lceil \log_2(k) \rceil$ bits. In order to maximize the use of the number of bits in {\ttfamily index}, and knowing that our program is working with 64-bit integers, we solve the following equation:
\begin{equation}
    k \cdot log_2(k) = 64 \iff k = 16
\end{equation}
If $k=16$, then $\lceil \log_2(k) \rceil = 4$. We use each $\lceil \log_2(k) \rceil$-bits in {\ttfamily index} to store the indices of the keys in {\ttfamily key}, ensuring that in {\ttfamily index} the

\chapter{Correctness tests}

\section{{\ttfamily Util} class tests}

\subsection{msb series tests}

The {\ttfamily Util} class contains many different implementations of the msb$(x)$ operation. Since Java's standard library offers a \{{\ttfamily Integer}|{\ttfamily Long}\}{\ttfamily.numberOfLeadingZeros(i)} static method, testing any implementation of msb$(x)$ is trivially done with the expression:

\{{\ttfamily Integer}|{\ttfamily Long}\}{\ttfamily.SIZE - 1 - }\{{\ttfamily Integer}|{\ttfamily Long}\}{\ttfamily.numberOfLeadingZeros(i)}

with the implementation from the class.

\subsection{{\ttfamily splitLong} and {\ttfamily mergeInts}}

For a determined range 64-bit keys, it evaluates if the following property holds for the whole range: {\ttfamily key == mergeInts(splitLong(key))}.

\subsection{Fields of words tests}

\subsection{Test for Rank Lemma 1}

\section{Integer Data Structure tests}

\subsection{Test parameters}

Each implementation of {\ttfamily RankSelectPredecessorUpdate} has a corresponding test class, which in turn has {\ttfamily Test} appended to its name. For example, the {\ttfamily BinarySearchTrie} test class is called {\ttfamily BinarySearchTrieTest} and it can be found in the {\ttfamily src/test/java} folder.

Each test class creates an instance of {\ttfamily RankSelectPredecessorUpdateTest} whose methods take a concrete implementation of {\ttfamily RankSelectPredecessorUpdate} to be tested. The constructor takes the following parameters:

\begin{itemize}
    \item {\ttfamily long seed}. This seed is used as parameter for instantiating a pseudo-random generator from the Java standard library --- {\ttfamily java.util.Random}. This instance will be later used to produce data for the test cases, such as seeds for passes (explained below), which in their turn will produce keys to be used in the tests.
    \item {\ttfamily int passes}. Some tests can be executed in more than one pass. A pass in a particular test consists of generating data with its corresponding seed and running the test with that data. When $passes > 1$, then different seeds are generated, which will result in different pseudo-random values and the test is run {\ttfamily passes} number of times.
    \item {\ttfamily int numKeys}. This parameter defines the size of the data set to be generated. It is particular important for testing for instance {\ttfamily DynamicFusionNode}, which size cannot exceed $k$.
\end{itemize}

\subsection{{\ttfamily insertAndMemberSmallTest()}}
The methods tested in this test are {\ttfamily insert} and {\ttfamily member}. A small set of predetermined keys is inserted in the set and then {\ttfamily member} is called on the set with each of those keys. 

\subsection{{\ttfamily smallCorrectnessTest()}}

An instance of a {\ttfamily RankSelectPredecessorUpdate} implementation is instantiated and keys are inserted such that after these insertions $S = \{10, 12, 42, -1337, -42\}$.

It is defined that:
\begin{itemize}
    \item Select queries can range between $0$ and $|S|-1$. Should any query fall outside this range, then {\ttfamily null} is returned, meaning, no result.
    \item $Select(0) = min\{y \in S \}$.
    \item $Select(|S|-1) = max\{y \in S\}$.
    \item Rank queries be any $w$-bit integer, and their possible range of results $\big[ 0, |S| \big]$
    \item Any given predecessor query returns the largest key in the subset of keys that are \textbf{strictly} smaller than the query, otherwise {\ttfamily null}.
    \item Whereas a successor query returns the queried key if present, otherwise the smallest key in the subset of keys that are larger than the query if any (and in such case {\ttfamily null} is returned).
\end{itemize}

With the given set and the above-mentioned rules, a small test is performed. Table~\ref{tab:smallCorrectnessTests} shows the expressions to be evaluated, and all of them must evaluate to {\ttfamily true} for the test to pass.

\begin{table}[H]
\centering
\input{src/tex/04_Tables/002_CorrectnessTestSmall}
\caption[Small correctness tests]{Small correctness tests.}
\label{tab:smallCorrectnessTests}
\end{table}


\subsection{{\ttfamily insertThenMemberTest()}}

The methods tested in this test are {\ttfamily insert} and {\ttfamily member}, and it can be executed in passes. It consists of:
\begin{enumerate}
    \item
    Iterating through all the the pseudo-randomly-generated keys and inserting them all in the instance to be tested.
    \item
    Iterating in random order through all the keys and asserting $key \in S$.
\end{enumerate}

\subsection{{\ttfamily insertThenDeleteRangeOfKeysTest()}}

The methods tested in this test are {\ttfamily insert} and {\ttfamily member}. It consists of iterating the whole range (which goes from $0$ to {\ttfamily numKeys}), where each iteration {\ttfamily i} consists of:
\begin{enumerate}
    \item
    Asserting that the key, {\ttfamily i} is not in the set by calling {\ttfamily member} on the set with the key.
    \item
    Inserting the key {\ttfamily i} in the set.
    \item
    Asserting that the key {\ttfamily i} is in the set.
\end{enumerate}
Should the number of keys exceed 9, then every $1/10$ of {\ttfamily numKeys} the data structures is reset and all keys are removed.

\subsection{{\ttfamily insertThenDeleteRandomKeysTest()}}

The methods tested in this test are {\ttfamily insert} and {\ttfamily delete} and it can be executed in passes. After inserting all the pseudo-randomly-generated keys in the set, the keys are iterated in random order. Each iteration consists of:
\begin{enumerate}
    \item Asserting that $key \in S$.
    \item Removing the key.
    \item Asserting that $key \not\in S$.
\end{enumerate}

\subsection{{\ttfamily deleteTest()}}

This test aims at asserting that only when deleting an existing key the cardinality of the set is altered. It tests the methods {\ttfamily delete} and size, and it can be executed in passes. At each pass:
\begin{enumerate}
    \item
    Pseudo-random keys are generated and delete on the set is called with that key.
    \item
    If the key was in the set, them the size must have decreased, otherwise it must remain the same.
\end{enumerate}

\subsection{{\ttfamily sizeTest()}}

The methods tested in this test are {\ttfamily insert}, {\ttfamily size} and {\ttfamily delete} and it can be executed in passes. Each pass consists of:
\begin{enumerate}
    \item
    Iterating the pseudo-randomly-generated keys in random order. At each iteration the key is inserted and it is asserted that {\ttfamily size} has increased by 1.
    \item
    After all the keys have been inserted, the keys are iterated in random order once more and at each iteration the key is removed and it is asserted that {\ttfamily size} has decreased by 1.
\end{enumerate}

\subsection{{\ttfamily growingRankTest()}}

This test aims ensuring that the following property holds for all the keys in the set: the rank of keys in sorted order is a monotone increasing function. It can be executed in passes and it is works the following way:
\begin{itemize}
    \item
    After inserting all the keys in the set, a copy of those keys is kept on a {\ttfamily TreeSet} (a set that keeps its values in sorted order) such that we can iterate them in their sorted order.
    \item
    A counter {\ttfamily i} is kept and initialized as $0$. It is incremented at each iteration.
    \item
    The test then asserts that the rank of the key is the same as the number of current iteration. Note that we can assume that this condition must hold because the keys are iterated in sorted order. 
\end{itemize}

\subsection{{\ttfamily selectOfRankTest()}}

This test aims ensuring that the following property holds for all the keys in the set: if a key is present in the set, knowing its rank and them querying for select of that must return the key. It can be executed in passes and it is works by iterating through the pseudo-randomly-generated keys and at each iteration it is asserted that {\ttfamily key == select(rank(key))}.

\subsection{{\ttfamily rankOfSelectTest()}}

This test aims ensuring that the following property holds for all the keys in the set: the rank of select a query is the query. It can be executed in passes and it is works by iterating from {\ttfamily 0} to {\ttfamily numKeys}. At each iteration {\ttfamily i}, it is asserted that {\ttfamily i == rank(select(i))}.